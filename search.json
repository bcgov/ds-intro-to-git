[
  {
    "objectID": "slides/slides.html#territorial-acknowledgement",
    "href": "slides/slides.html#territorial-acknowledgement",
    "title": "Version Control using Git + GitHub",
    "section": "Territorial Acknowledgement",
    "text": "Territorial Acknowledgement\n\n\nPhoto Source: Mystic Beach, Vancouver Island, Canada 10 © Michal Klajban, CC BY-SA 4.0.\n\n\nI’d like to open today’s workshop with a territorial acknowledgement.\nI acknowledge with respect the Coast Salish Peoples on whose traditional lands and waterways we live, learn and play. I am grateful for the opportunity to share in this beautiful region, and I aspire to healthy and respectful relationships with those who have lived on and cared for these lands for a millennia. (pause and next slide)"
  },
  {
    "objectID": "slides/slides.html#housekeeping",
    "href": "slides/slides.html#housekeeping",
    "title": "Version Control using Git + GitHub",
    "section": "Housekeeping",
    "text": "Housekeeping\n\n\n\n\n\nLive coding event: (not being recorded)\nBest practices for learning virtually\n\nWhat to do with questions?\nMicrophones on mute\nGetting disconnected\nCameras on at first.\n\nCourse materials\nOur request: try your best\n\n\n\nCourse Materials: https://bcgov.github.io/ds-intro-to-git\n\n\nFirst, some housekeeping! (next)\nAs part of today’s workshop, we’ll be coding in real time, working through concepts together on the fly. This approach lets us explore the process interactively. While this can be dynamic and fun, it also means there may be moments where we need to debug or adjust as we go. (next)\nSince we’ll be coding in real time, it’s important that everyone feels comfortable and engaged. To keep things running smoothly in our virtual setting, let’s go over a few best practices: (next)\n\nIf you have questions, please feel free to drop them in the chat or use the ‘raise hand’ feature—we’ll address them as we go. Your engagement and questions will make this experience even more valuable, so don’t hesitate to share your thoughts along the way! (next)\nKeep your microphones on mute unless speaking to minimize background noise. (next)\nAnd if we get disconnected, don’t worry! You can rejoin using the same meeting link, and Lindsay will let you back in. (next)\nCameras on for the first bit so the faciliators get to know who you are and can put a face to a name. (next)\n\nThe link to the course materials was sent with the pre-workshop assignment and installation instructions. For your convenience the link is at the bottom of the slide. I can drop it in the chat as well https://bcgov.github.io/ds-intro-to-git. (next)\nWe have one request and that is to try your best.\nWe’re all learning together. Git and GitHub can feel a little overwhelming at first, but the goal isn’t perfection — it’s progress.\nMistakes are part of the process, and they’re a great way to learn. Don’t hesitate to experiment, ask questions, or even mess something up—that’s how we figure things out. Remember, no one here expects you to know everything right away, and we have great people assisting to help guide you through it.\nSo let’s dive in with curiosity and determination, and remember - every small step in learning builds a stronger future you.\n(next slide)"
  },
  {
    "objectID": "slides/slides.html#workshop-code-of-conduct",
    "href": "slides/slides.html#workshop-code-of-conduct",
    "title": "Version Control using Git + GitHub",
    "section": "Workshop Code of Conduct",
    "text": "Workshop Code of Conduct\n\n\nWe aim to make this a welcoming and supportive environment for everyone, regardless of background\nWe encourage respectful discussion and questions throughout the course\nPlease be fully present and engaged during the session (that email can wait!)\n\n\n\nLearn more: Standards of Conduct for BC Public Service employees\n\n\nLet us take a moment to share our workshop code of conduct. These guidelines are in place to ensure this session remains a positive and productive space for everyone: (next)\nFirst and foremost, we aim to create a welcoming and supportive environment for all participants, regardless of background. (next)\nWe encourage respectful discussion and questions throughout the session. Healthy dialogue enriches the learning experience, but it’s important to maintain a tone of mutual respect as teaching and learning in a virtual environment can be hard. Remember to be kind not only to others but also to yourself—mistakes and misunderstandings are part of the learning process. Let’s focus on building each other up and avoiding criticism, so everyone feels supported and encouraged to grow. (next)\nFinally, we ask that you be fully present and engaged during the workshop. Multitasking can wait—this is your opportunity to focus and get the most out of our time together.\nBy following these principles, we can create a space where everyone feels comfortable and valued. Thanks in advance for your cooperation.\n(next slide)"
  },
  {
    "objectID": "slides/slides.html#workshop-outline",
    "href": "slides/slides.html#workshop-outline",
    "title": "Version Control using Git + GitHub",
    "section": "Workshop Outline",
    "text": "Workshop Outline\n\n\n\n\n\nSection 1: What is version control for code\n\nWhy do we want to use it?\n\nSection 2: Working locally with Git\n\nSetting up our first Git repository\n\nSection 3: Remote code-hosting and GitHub\n\nSharing code on GitHub\n\nSection 4: BCGov GitHub Organization\n\nCoding in the open\n\n\n\n\n\n\n        \n\n\n\nCourse Materials: https://bcgov.github.io/ds-intro-to-git\n\n\nTo give you a clear picture of what we’ll be covering today, here’s an outline of our workshop. This also can be found in our course materials. (next)\nSection 1: What is Version Control for Code. (next) We’ll start by exploring the concept of version control, what it is and why it’s an essential practice in modern coding. (next)\nSection 2: Working Locally with Git. (next) We’ll dive into Git, learning how to set up and work with our first Git repository. (next)\nSection 3: Remote Code-Hosting and GitHub. (next) In this section, we’ll focus on using GitHub to share and collaborate on code. (next)\nSection 4: BCGov GitHub Organization. (next) In this section we’ll discuss coding in the open, leveraging the BCGov GitHub organization to manage and share projects effectively. (next)\nThese icons represent our sections. You’ll see them at the top right hand-side of most of the presentation slides. If you get lost these are here to to cue you which topic or skill we are working on as we progress through the course.\nThis structured approach will guide us step-by-step from foundational concepts to practical applications, ensuring you gain both understanding and hands-on experience.\n(next slide)"
  },
  {
    "objectID": "slides/slides.html#installation-set-up-review",
    "href": "slides/slides.html#installation-set-up-review",
    "title": "Version Control using Git + GitHub",
    "section": "Installation & Set Up Review",
    "text": "Installation & Set Up Review\n\n\nInstalled Git (including Git Bash): Git Download\nCreated a GitHub account: Pre-Workshop Materials\n\nSet-up 2FA/MFA\nCreated a Personal Access Token\n\nConfigured Git: Pre-Workshop Materials\n\n\n\nLearn more: Software Installation Guide\n\n\nBefore diving into today’s workshop, let’s quickly review the foundational steps you’ve already completed in preparation for this course. (next)\nYou’ve downloaded and installed Git from the Git website. This included Git Bash, a terminal that allows you to interact with Git through command-line commands. (next)\nYou set up a GitHub account, which will allow you to store and collaborate on code projects in a cloud-based repository. (next)\nAs part of this process you enabled Two-Factor Authentication (2MFA) to enhance account security. (next)\nYou also created a Personal Access Token to allow Git to authenticate securely with your GitHub account for operations like pushing or pulling code. (next)\nYou also configured Git by setting up your username and email address, which ensures that every change you commit is associated with your identity. Most of you did this in Git Bash terminal. If you need a refresher, the configuration steps can be found in the pre-workshop materials. (next)\nI’d like everyone to please take a minute to check your configurations.\nThese steps provided the groundwork for today’s workshop, ensuring you have the tools and configurations necessary to follow along effectively. If you encounter any challenges related to these steps, feel free to drop a question into the chat for assistance. (next)"
  },
  {
    "objectID": "slides/slides.html#section-1-what-is-version-control",
    "href": "slides/slides.html#section-1-what-is-version-control",
    "title": "Version Control using Git + GitHub",
    "section": "Section 1: What is Version Control?",
    "text": "Section 1: What is Version Control?\n\n\nSource: notFinal.doc by Jorge Cham © 2012\n\n\nWhat’s version control?\nNot this. But we’ve all been in this situation before: it seems unnecessary to have multiple nearly-identical versions of the same document – either by yourself or spread around among colleagues. It’s difficult to tell the difference between files, and what was changed when, by whom, and why?\nVersion control is the practice of tracking and managing changes to software code. Version control systems (like Git) are software tools that are used to help teams manage changes to code and documents over time.\nConsider the following scenario. You and your colleagues have been asked to do an analysis of the Work Environment Survey study to determine if workplace satisfaction has increased or decreased significantly since the start of the pandemic. You and your colleagues want to be able to work on the project at the same time, but have run into problems doing this in the past. If you take turns, each of you will spend a lot of time waiting for the other to finish, but if you work on your own copies and save them to the local network, things will be lost, overwritten, or duplicated. A colleague suggests using version control to manage your work."
  },
  {
    "objectID": "slides/slides.html#changes-saved-sequentially",
    "href": "slides/slides.html#changes-saved-sequentially",
    "title": "Version Control using Git + GitHub",
    "section": "Changes saved sequentially",
    "text": "Changes saved sequentially\n\n\nShe mentions she uses Git and provides you an online link. You decide to do some light reading. You find out git keeps track of snapshots in time – each document or file starts with a base version and then you tell git to save just the changes you made at each step of the way.\nYou decide which changes make up the each snapshot, and git stores those changes and keeps useful metadata about them.\nYou can think of it as a recording of your progress: you can rewind to start at the base document (the one on the left) and play back each change you made, eventually arriving at your more recent version (the one on the right).\nEach of these three snapshot are called a ‘commit’."
  },
  {
    "objectID": "slides/slides.html#collaborating-branching",
    "href": "slides/slides.html#collaborating-branching",
    "title": "Version Control using Git + GitHub",
    "section": "Collaborating Branching",
    "text": "Collaborating Branching\n\n\n\n\n\n\n\n\n\n\nMultiple users: different people work on their own copy\nEach can branch off the original work independently\n\n\n\n\nBut git also allows independent users to make changes on the same document. (next) (next)\nEach can, on their own copy, head off on a different track and work on it independently while keeping the main copy intact.\nIn this diagram person green takes a copy of the base document on the left, and person red also takes a copy. They add some lines of text and when they are finished making changes to their own copy…\n(next slide)"
  },
  {
    "objectID": "slides/slides.html#collaborating-merging",
    "href": "slides/slides.html#collaborating-merging",
    "title": "Version Control using Git + GitHub",
    "section": "Collaborating: Merging",
    "text": "Collaborating: Merging\n\n\n\n\nMerge changes made by each person back into the same base document.\nDocuments kept in sync across different computers\n\n\n\n\n\n\n\n\n\n\nthe changes they want to keep can be merged back into the original. If they don’t like the result, the changes can be discarded. (next)\nUnless multiple users make changes to the same section of the document (this is called a conflict) you can incorporate two sets of changes into the same base document. (next)\nDocuments and repositories can be kept in sync across different computers facilitating collaboration among different people."
  },
  {
    "objectID": "slides/slides.html#version-control-repository",
    "href": "slides/slides.html#version-control-repository",
    "title": "Version Control using Git + GitHub",
    "section": "Version Control Repository",
    "text": "Version Control Repository\n  A repository is a data structure that stores metadata for a set of files or directory structure, as well as a historical record of changes to the repository.\n\nHow does git accomplish this? It leverages something called a repository (or repo, for short)\nIn version control systems, a repository is a data structure that stores metadata for a set of files or directory structure, as well as a historical record of changes to the repository.\nYou store all of your project files in a folder.\nAll of the files, plus the complete history for the files in that folder make up a repository (repo)."
  },
  {
    "objectID": "slides/slides.html#version-control-repository-1",
    "href": "slides/slides.html#version-control-repository-1",
    "title": "Version Control using Git + GitHub",
    "section": "Version Control Repository",
    "text": "Version Control Repository\n\nWES Project Folder\n├── wes-analysis\n  ├── doc\n  ├── ref\n  │ ├── references\n  │ ├── images\n  ├── plots\n  ├── code\n  ├── data\n  │ ├── wes-results\n  │ │ ├── wes-results-2019.csv &lt;– DON’T WORRY, THESE WON’T BECOME PUBLIC!\n  │ │ ├── wes-results-2020.csv\n  │ │ ├── wes-results-2021.csv\n  │ | |── wes-results-2022.csv\n  ├── .git &lt;———————— THIS MAKES IT A GIT REPOSITORY!\n  ├── .gitignore &lt;————– FILES listed here are ignored by git not tracked, e.g., csv files\n\n\nThis slide illustrates the structure of a typical Git repository. Let me walk you through its key components: (next)\nAt the top level, we have the wes-analysis folder, which is the root directory of this repository. This is where all our files and folders for the project are organized. Inside this folder you likely have other project-related subfolders such as:\n\ndoc and ref which may contain files such as a list of acronyms, reports, reference materials and possibly articles and images for visual documentation or presentations.\nplots is where visual outputs like graphs or charts from the analysis are saved.\ncode houses the scripts or programming files you’re working on, forming the core of the project’s logic. (next)\ndata contains the raw data files in this hypothetical project. It’s worth noting that sensitive or private data, like these CSV files, won’t become public as we will give explicit instructions to git to ignore them.\n\nTwo important files help manage this repository (next)\nThe .git directory is hidden by default and is what makes this a Git repository. It tracks changes to files, allowing us to manage versions of our code and content. (next)\nThe .gitignore file lists files or filename patterns we don’t want Git to track—like large data files such as the CSVs. This is a common practice to keep repositories clean and focused on the essential project elements. (next)\nTogether, this structure keeps our work organized and ensures that the repository is ready for version control and collaboration."
  },
  {
    "objectID": "slides/slides.html#section-2-working-locally-with-git",
    "href": "slides/slides.html#section-2-working-locally-with-git",
    "title": "Version Control using Git + GitHub",
    "section": "Section 2: Working locally with Git",
    "text": "Section 2: Working locally with Git\n\n\n  \n\n\n\n\n\nTrack changes in files\n\nSource code\n\nManage versions of your work\nFacilitates collaboration\nBranching and merging\nDistributed model\n\n\n\n\n(next) (next)\nGit is a distributed version control system designed to track changes in files, particularly source code. (next)\nGit helps us manage versions of our work, making it easy to revert to earlier states or identify when and why changes were made. (next)\nIt enables multiple people to collaborate on projects while maintaining a detailed history of all changes. It enables contributors to work simultaneously without overwriting each other’s work. (next)\nGit supports parallel development, allowing teams to work on different features or fixes without interference. This is done through branching and merging which we introduced earlier and will review shortly. (next)\nGit is a distributed model, meaning every user has a full copy of the repository. The benefit here is that operations require only local files and resources. This makes Git extremely fast and reliable.\nUnlike many version control systems that treat data as a list of file changes over time, Git thinks of data as a series of snapshots of a miniature filesystem. Every time you commit, Git essentially takes a snapshot of your project’s state and stores a reference to it.\nIt’s impossible to change files or directories without Git detecting it. This ensures you don’t lose information in transit or encounter undetected file corruption.\nOnce a snapshot is committed to Git, it’s incredibly hard to lose, especially if you regularly push your changes to a remote repository."
  },
  {
    "objectID": "slides/slides.html#preview-git-jargon",
    "href": "slides/slides.html#preview-git-jargon",
    "title": "Version Control using Git + GitHub",
    "section": "Preview: Git Jargon",
    "text": "Preview: Git Jargon\n\n\n\n\nrepo\nstage/add\ncommit\npush\npull\n\n\n\n\n\nclone\nbranch\nfork\n\n\n\n\nLet’s preview a bit of git Bash jargon. Many of these are commands that we enter at command-line. Let’s start with the ones we’ll use in the workshop. (next)\nA repo (short for repository) is like a folder where your project’s files and their history are stored. It tracks all the changes you make, letting you see the past versions and collaborate with others. You can have a local repo on your computer or a remote one on a platform like GitHub. (next)\nadd a git command used to stage files. it is like putting changes into a “ready-to-go” box. It tells Git which changes (new files, edits, or deletions) you want to save in your next snapshot (commit). You’re just preparing them; they aren’t saved yet. (next)\ncommit -m \"message a git command used to take a picture of your work at this moment. It saves the changes you’ve prepared (staged) into Git’s history. When we commit changes, we add a message. This is like a caption, helping you remember what this “snapshot” is about. (next)\npush [remote] [branch] a git command used to send your saved work (commits) from your computer to an online storage space (remote repository). This lets others see or work with your updates. (next)\npull [remote] [branch] a git command used to grab the latest updates from the online version of your project and add them to your work. It makes sure you’re working with the most up-to-date version. (next)\nSome others you may hear about but we won’t be directly going over today.\nclone [repositoryurl] a git command used to download a full copy of a project from an online source (like GitHub) to your computer so you can work on it. It brings all the files and the project’s history with it. (next)\nbranch [branchname] is like a new “workspace” where you can try new ideas or work on features without messing with the main project. Branches keep your main project safe while you experiment or build new things, and you can later combine your changes when they’re ready. (next)\nfork: No direct Git command as forking is done through GitHub platform. It’s like making your own personal copy of someone else’s project, so you can change it without affecting their original work. You can use it to contribute to open-source projects or customize things for your own needs. Once you’re happy with your changes, you can share them back with the original project through a pull request. (next)"
  },
  {
    "objectID": "slides/slides.html#preview-bash-jargon",
    "href": "slides/slides.html#preview-bash-jargon",
    "title": "Version Control using Git + GitHub",
    "section": "Preview: Bash Jargon",
    "text": "Preview: Bash Jargon\n\n$ cd path/to/directory          # Go to specified directory - \"quotes\" are needed if there are spaces \n$ cd ..                         # Go up one directory level\n$ mkdir new_directory           # Create specified directory\n$ ls                            # List directories and files\n$ ls -a                         # List directories and files, including hidden\n\n\nSome common Bash commands that we’ll need to navigate our file system when working with Git are listed here. (next)\ncd path/to/directory: This command lets you navigate to a specific directory. Think of it as ‘changing your location’ in the file system. If the directory path includes spaces, make sure to enclose it in quotes, like cd “My Folder”. (next)\ncd ..: The .. represents the parent directory. Using this command moves you up one level in the directory hierarchy. For example, if you’re in a folder called projects, cd .. will take you back to its parent folder. (next)\nmkdir new_directory :This creates a new directory with the specified name. It’s a quick way to organize your files into new folders directly from the command line. (next)\nls: This lists the contents of the current directory, showing all files and subdirectories. It’s a handy way to see where you are and what’s in your folder. (next)\nAdding the -a flag shows all files, including hidden ones. Hidden files usually start with a dot, like .git, and they’re essential for tasks like managing Git repositories. (next)\nThese commands form the foundation of navigating and organizing your files in the terminal, which is key to working effectively with Git.\n(next slide)"
  },
  {
    "objectID": "slides/slides.html#hands-on-practice",
    "href": "slides/slides.html#hands-on-practice",
    "title": "Version Control using Git + GitHub",
    "section": "Hands-On Practice",
    "text": "Hands-On Practice\n    Let’s create our first repository!"
  },
  {
    "objectID": "slides/slides.html#the-staging-area",
    "href": "slides/slides.html#the-staging-area",
    "title": "Version Control using Git + GitHub",
    "section": "The Staging Area",
    "text": "The Staging Area\n\n\n\n\n\n\n\n\nBest Practice Workflow:\n\nstage and commit changes explicitly\ngit add &lt;filename&gt; followed by git commit -m ‘message’\n\n\n\n(next)\nAs a final note, Git requires us to explicitly add files to a staging area before committing them. This lets us organize our work and commit changes in logical portions rather than committing everything at once.\nFor example, if you’re working on a thesis, you might want to commit newly added citations and bibliography entries separately from unfinished work in the conclusion.\nThink of Git as taking snapshots of your project’s history.\ngit add tells Git what will be included in the next snapshot by placing files into the staging area.\ngit commit actually takes the snapshot and makes a permanent record of it.\nIf you type git commit without staging anything, Git will prompt you to use options like git commit -a or git commit --all which is kind of like gathering everyone to take a group photo. While these commands gather all changes at once, it’s better to stage manually with git addinstead of accidentally including changes you didn’t mean to commit. (next)\nBest Practices:\n\nAlways stage changes explicitly to maintain control over what goes into each commit.\n\nThis practice helps you avoid mistakes and keeps your project history clean and well-organized.\n\nBy staging changes, you’re breaking down your work into manageable, logical pieces—an approach that makes your version control workflow much more efficient."
  },
  {
    "objectID": "slides/slides.html#review-git-jargon",
    "href": "slides/slides.html#review-git-jargon",
    "title": "Version Control using Git + GitHub",
    "section": "Review: Git Jargon",
    "text": "Review: Git Jargon\n\n$ git init                          # initiate a repository in the current directory\n$ git status                        # indicate if there are any changes to files\n$ git add &lt;filename&gt;                # add a new file/change to the staging area\n$ git commit –m “commit message”    # commit all staged changes to the repository\n$ git log                           # view commit history\n$ git diff                          # show changes between commits\n$ git restore                       # restore file/s to previous commit\n\n\nAt that point, let’s review some of the essential Git commands we’ve seen..\ngit init: This command initialized a Git repository in the current directory. It created a hidden .git folder, which Git used to track changes to files. This only needed to be done once per project to start version control.\ngit status: Running this command gave a snapshot of the repository’s current state. It showed any changes to files, whether they had been staged for commit, and if there were untracked files. It was like a ‘to-do list’ for what was happening in Git.\ngit add mars.txt: This staged a file or changes to a file, staging it for the next commit.\ngit commit -m \"commit message\": This command took all the changes in the staging area and committed them to the repository, creating a new snapshot. The -m flag allowed us to add a message describing the changes, which was critical for understanding the history later.\ngit log: This command was used to view the commit history of the repository. It showed who made the changes, when they were made, and the commit messages. Generally, this is an excellent way to review the progress of a project.\ngit diff: This displayed the changes between commits or the differences between the working directory and the last commit (the HEAD). It was useful for checking exactly what had changed before committing.\ngit restore: This restored mars.txt to our previous commit, effectively undoing changes. It was handy for discarding changes or returning a file to a specific version.\nThese commands form the backbone of working with Git. As you use them, you’ll develop a deeper understanding of how Git tracks and manages your work.”\n(next slide)"
  },
  {
    "objectID": "slides/slides.html#section-3-remote-code-hosting-and-github",
    "href": "slides/slides.html#section-3-remote-code-hosting-and-github",
    "title": "Version Control using Git + GitHub",
    "section": "Section 3: Remote code-hosting and GitHub",
    "text": "Section 3: Remote code-hosting and GitHub\n\n\n\n\n\n\n\n\n \n\n\nHosting service for git repositories\nGreatly facilitates collaboration\nGit: Version Control +\nHub: Centralized repos & networking/collaborating\n\n\n\n\nIn this section we are going to take a closer look at GitHub, one of the most widely used hosting services for Git repositories. Then we’ll create a remote repository for our local planets repo and cconnect the two.\nGitHub is a platform that hosts Git repositories in the web and provides a web interface to interact with repos. It’s main function is to host the ‘remote’ or main copy of a git repository (next)\nHosting Service for Git Repositories:\nAt its core, GitHub is a platform for storing and managing Git repositories in the cloud. It acts as a central hub where your project lives online, making it accessible to team members and collaborators anywhere in the world. (next)\nFacilitates Collaboration:\nGitHub simplifies working together by enabling multiple people to contribute to the same project seamlessly.\nWith features like pull requests, code reviews, and issue tracking, it ensures that teams can work efficiently and stay organized, even when working remotely. (next)\nLet’s breaking down the name – Git + Hub:\nGit: The powerful version control system that tracks changes in your project, keeping a detailed history of your work. (next)\nHub: A central place for repositories where networking and collaboration happen. Think of it as the meeting point where all your team’s work comes together.\nWith GitHub, you’re not just managing your code; you’re enabling teamwork, encouraging innovation, and building a shared space for your projects to thrive."
  },
  {
    "objectID": "slides/slides.html#git-github-working-collaboratively",
    "href": "slides/slides.html#git-github-working-collaboratively",
    "title": "Version Control using Git + GitHub",
    "section": "Git + GitHub: Working Collaboratively",
    "text": "Git + GitHub: Working Collaboratively\n\n\nVersion control really comes into its own when we begin to collaborate with other people. We already have much of the machinery we need to do this; what we are missing is something that allows us to copy changes from one repository to another.\nIn this scenario, multiple people are working on their own copies of a single repository. Instead of passing files back and forth, Git allows them to seamlessly share and sync their work across multiple repositories. The magic happens with a central repository—the single source of truth—that lives on the web, in GitHub. Everyone involved in the project keeps a local copy of the shared repository, making changes and updates on their own computers. The changes are merged into our source of truth repository in GitHub.\nIn the pre-workshop you created a GitHub account, linked it with a personal access token (PAT) and MFA, thereby configuring your system to connect to GitHub. This setup will allow us to create a remote repository, sync it with our local work, and share our progress with collaborators—or even the world."
  },
  {
    "objectID": "slides/slides.html#remote-repository",
    "href": "slides/slides.html#remote-repository",
    "title": "Version Control using Git + GitHub",
    "section": "Remote Repository",
    "text": "Remote Repository\n\n\n\n\n\n\n\nThink of the remote as the “authoritative” version/source/copy.\nIf you remember back to the earlier episode where we added and committed our earlier work on mars.txt, we had a diagram of the local repository which looked like this: (next)\nNow that we have two repositories, we need a diagram like this: (next)\nOur local repository still contains our earlier work on mars.txt, but the remote repository on GitHub appears empty as it doesn’t contain any files yet."
  },
  {
    "objectID": "slides/slides.html#hands-on-practice-1",
    "href": "slides/slides.html#hands-on-practice-1",
    "title": "Version Control using Git + GitHub",
    "section": "Hands-On Practice",
    "text": "Hands-On Practice\n    Let’s create our first remote repository!\n\nLet’s make our first remote repository!\n(flip to section 3.1)"
  },
  {
    "objectID": "slides/slides.html#a-collaborative-workflow",
    "href": "slides/slides.html#a-collaborative-workflow",
    "title": "Version Control using Git + GitHub",
    "section": "A Collaborative Workflow",
    "text": "A Collaborative Workflow\n\n\n\n\nOriginal Repository\n|── planets\n| |──.git\n| |── mars.txt\n\n\n\n\n| |── pluto.txt\n\n\n\n\n\nGitHub Repository\n|── planets\n| |── .git\n\n\n\n\n| |── mars.txt\n\n\n\n\n| |── pluto.txt\n\n\n\n\n\nCloned Repository\n|── planets\n| |── .git\n| |── mars.txt\n\n\n\n\n| |── pluto.txt\n\n\n\n  \n\n\n\n\n\n\n\nInitial repository set up\n\n\n\n\n\n\nRemote repository created & linked\n\n\n\n\n\n\nLocal changes pushed to remote\n\n\n\n\n\n\nRemote repository cloned by collaborator\n\n\n\n\n\n\n\nCollaborator makes additions\n\n\n\n\n\n\nCollaborator updates remote with changes\n\n\n\n\n\n\nCollaborator changes pulled back to original\n\n\n\n\n\n\n\nAt this point, stop and compare the three repositories. (next)\n\nWe started with our initial repository called planets. Created our hidden .git directory and mars.txt and commited these to our local repository. (next)\nWe then created a remote repository on GitHub which was initialized with a .git directory. (next)\nWe pushed our local changes (our new file mars.txt) to our remote on GitHub. (next)\nOur colleague, working on another computer, clone the planets repo (along with text file and hidden git directory) to their local machine.\n\nWe now have three identical repositories in three locations. Our colleague wants to:\n\nadd a new file with information on Pluto. (next)\n\nLet’s go ahead and try this out. (flip to bash terminal)\n\nWith pluto.txt file in the cloned repository we communicated the (by pushing) the changes to our source of truth remote repository (next)\nAfter pulling all the changes from the remote repository back to the original, our three repositories (original local, second local, and the one on GitHub) are back in sync!"
  },
  {
    "objectID": "slides/slides.html#a-typical-workflow",
    "href": "slides/slides.html#a-typical-workflow",
    "title": "Version Control using Git + GitHub",
    "section": "A Typical Workflow",
    "text": "A Typical Workflow\nThe table below doubles as a handy cheatsheet; take a screenshot and save for future reference!\n\n\n\n\n\n\n\n\n\nOrder\nAction\nGit Command\n\n\n\n\n1 (Once Only)\nCreate remote\n(Done on GitHub)\n\n\n2 (Once Only)\nClone remote\ngit clone https://github.com/path/to/remote\n\n\n3\nUpdate local\ngit pull origin main\n\n\n4\nMake changes\n(Done in editor)\n\n\n5\nStage changes\ngit add numbers.txt\n\n\n6\nCommit changes\ngit commit -m \"Add 100 to numbers.txt\"\n\n\n7\nUpdate remote\ngit push origin main\n\n\n\n\n\nTo this point, we have learned a lot of different git commands and workflows involved in tracking all of our changes, keeping our repositories up-to-date, and collaborating across computers using GitHub. While there are multiple levels of nuance that go into each of these steps, let’s lay out a typical workflow."
  },
  {
    "objectID": "slides/slides.html#ignoring-things",
    "href": "slides/slides.html#ignoring-things",
    "title": "Version Control using Git + GitHub",
    "section": "Ignoring things",
    "text": "Ignoring things\n\n\n\nOriginal Repository\n|── planets\n| |──.git\n| |── mars.txt\n| |── pluto.txt\n\n\n\n| |── data.csv\n\n\n\n\n| |── .gitignore\n\n\n\n\n\n\n\n\n\n\n\n\nWhat if we have files that we do not want Git to track for us, like backup files created by our editor or intermediate files created during data analysis? This often is the case in BC Government data projects. (next)\nAND We KNOW many BC Stats projects involve data with PI or other sensitive information. (next)\nWe generally follow a best practice of not pushing data to GitHub. (next)\nWe accomplish this by creating a file in the root directory of our project called a .gitignore.\n.gitignore files are plain text files; you can open the file with your chosen text editor and add the names of any files or folder you don’t want to commit and therefore they won’t accidently get pushed to GitHub. Let’s try this. (flip over to Git Bash)"
  },
  {
    "objectID": "slides/slides.html#section-4-bcgov-github-organization",
    "href": "slides/slides.html#section-4-bcgov-github-organization",
    "title": "Version Control using Git + GitHub",
    "section": "Section 4: BCGov GitHub Organization",
    "text": "Section 4: BCGov GitHub Organization\n\n\nset up in early 2014\nOCIO + BCDevExchange team\nDigital Principles for the B.C. Government: “work in the open”\nbcgov: open-source code\nbcgov-c: confidential code\n\n\n\nIn this final section, we’re going to talk about how the B.C. Government is embracing open collaboration through the BCGov GitHub organization or for short, bcgov github, or just bcgov. The BCGov GitHub organization is the official platform for open-source projects within Provincial Government of BC.\n\nLet me give you a little backstory: (next)\n\nThe bcgov organization was set up in early 2014 by the OCIO, in collaboration with the BCDevExchange team within the Ministry of Citizen’s Services. (next)\nWhy? Because we recognized the need to share code and work transparently—and GitHub was the perfect platform to make that happen! (next)\n\nOur Digital Principles for the B.C. Government urges all government product teams to work in the open. GitHub makes this easier by providing tools to:\n\nCollaborate with the open-source community.\n\nShare and control versions of our code.\n\nAutomate processes.\n\nAnd, of course, track and resolve issues. (next)\n\n\nThe primary organization, bcgov, houses open-source code developed by government teams. This includes projects with both open-source and inner-source contribution models, with over 1,000 repositories available. (next)\nFor confidential code, developers use the bcgov-c organization, ensuring secure storage and management."
  },
  {
    "objectID": "slides/slides.html#section-4-bcgov-github-organization-1",
    "href": "slides/slides.html#section-4-bcgov-github-organization-1",
    "title": "Version Control using Git + GitHub",
    "section": "Section 4: BCGov GitHub Organization",
    "text": "Section 4: BCGov GitHub Organization\n\n\n\n\n\n\n\n\n\nBCGov: https://github.com/bcgov\n\n\nThe BCGov GitHub organization overview page has changed recently. If you navigate to this page on GitHub (the url is at the bottom of the screen), you will be presented with a README. (zoom in, alt right-click)\nThe README speaks to the organization’s:\n\nPurpose and Vision:\nRole of Developers:\nSupport Resources and (next)\nseveral other links including one for instructions on how to join the community.\n\n(zoom out, alt+right-click)\nThis link takes us to…"
  },
  {
    "objectID": "slides/slides.html#bc-developer-guide",
    "href": "slides/slides.html#bc-developer-guide",
    "title": "Version Control using Git + GitHub",
    "section": "BC Developer Guide",
    "text": "BC Developer Guide\n\n\nBC Developer Guide: https://developer.gov.bc.ca\n\n\n…the BC Developer guide, which is a living guide to application development for the B.C government, updated regularly by the Developer Experience team. It’s written for all ministries as a guide for your team’s technical decisions and as a reference throughout your coding products.\nIt contains a section that\n\ngives an overview of the different GitHub Organizations, (bcgov and bcgov-c) and details the purpose and access rules for each organization.\n\nDescribes the SSO setup process for bcgov and bcgov-c organizations, including requirements for IDIR accounts and steps for linking accounts.\n\nWhat I want to highlight is the step-by-step guides for signing up and linking GitHub accounts to bcgov and bcgov-c.\n\nThe step-by-step instructions outline key requirements like two-factor devices, personal logins, and IDIR credentials.\n\nList links to supplementary guides, video tutorials, and support request options."
  },
  {
    "objectID": "slides/slides.html#bcgov-github-organization",
    "href": "slides/slides.html#bcgov-github-organization",
    "title": "Version Control using Git + GitHub",
    "section": "BCGov GitHub Organization",
    "text": "BCGov GitHub Organization\n\n\n\n\n\n\n\n\n\nBCGov: https://github.com/bcgov\n\n\nGoing back to the bcgov github overview page (next) At the top is a link to BCGov GitHub Policy Framework (next slide)"
  },
  {
    "objectID": "slides/slides.html#bcgov-github-policy-framework",
    "href": "slides/slides.html#bcgov-github-policy-framework",
    "title": "Version Control using Git + GitHub",
    "section": "BCGov GitHub Policy Framework",
    "text": "BCGov GitHub Policy Framework\n\n\nBCGov Policy Framework: https://github.com/bcgov/BC-Policy-Framework-For-GitHub\n\n\nScrolling down to the bottom you will find a README."
  },
  {
    "objectID": "slides/slides.html#bcgov-github-policy-framework-1",
    "href": "slides/slides.html#bcgov-github-policy-framework-1",
    "title": "Version Control using Git + GitHub",
    "section": "BCGov GitHub Policy Framework",
    "text": "BCGov GitHub Policy Framework\n\n\n\n\n\n\nJoining\nOpening & Contents of Repositories\nLicensing\nPrivacy, Security, Copyright\nAppropriate Use\nHow to’s\n\n\n\n\nIn that README you’ll find links to:\n\nA HOW-TO, containing a list of tips, tricks and best practices for using GitHub as a code repository for government projects.\nAn employee guide. Which is a guide for developing in GitHub for BC Government employees. This contains information on licensing, conflict of interest and appropriate use policy\nAlso a cheatsheet with resources for joining BCGOV, using git, adding required files, how to properly license the contents of a repository"
  },
  {
    "objectID": "slides/slides.html#mandatory-content",
    "href": "slides/slides.html#mandatory-content",
    "title": "Version Control using Git + GitHub",
    "section": "Mandatory Content",
    "text": "Mandatory Content\n\n\nLet’s take a look at the mandatory files you’ll typically find in most GitHub repositories. These files aren’t just important—they’re essential for ensuring a well-organized and collaborative project:\nLICENSE: The license file specifies the terms under which others can use, modify, or distribute the project. It’s crucial because it makes clear what permissions are granted. For example, is this code free to use? Can someone adapt it for their own work? Without a license, your project defaults to being fully restricted, which can limit its usability. Generally, for bcgov repositories we use the Apache 2.0 LICENSE:\n\nThis can be added directly to the repository\nBoiler-plate for the Apache 2.0 LICENSE is added to the bottom of your README.md\nBoiler-plate for the Apache 2.0 LICENSE is added to the comments header of every source code file\n\nOther, non-code files may require a second license, such as the Creative Commons Attribution 4.0 International. This can be added in a footer to your README.md\nREADME: This is the front page of your repository. It’s often the first thing anyone sees when visiting your project. It explains what the project is about, what problem it solves, how to use it, and sometimes even a roadmap for future development. Think of it as your project’s introduction and user guide rolled into one.\nCONTRIBUTING: This file guides others who want to contribute to your repository.\nCODE-OF-CONDUCT: Open Source space in general has had its struggles with conduct and one approach to improving this is establishing clear code of conduct for open source projects. Most often this is a statement around fostering an open, safe, welcoming, and respectful inclusive community for all. It emphasizes fostering a kind, inclusive, cooperative, and harassment-free open source BCGov community"
  },
  {
    "objectID": "check_compliance.html",
    "href": "check_compliance.html",
    "title": "Introduction to Version Control with Git & GitHub",
    "section": "",
    "text": "from github import Github, UnknownObjectException, GithubException\nimport logging\n\nlogging.getLogger('matplotlib.font_manager').disabled = True\n\nwith open('config.txt', 'r') as config_file:\n    auth = config_file.readline().strip('\\n')\n\n\n# First create a Github instance:\ng = Github(login_or_token=auth)\n\n\n\n# get the organization of interest\norg = g.get_organization('bcgov')\n\n\nfiles_dict = {\n    'repo': [],\n    'readme': [],\n    'contributing': [],\n    'license': [],\n    'code_of_conduct': []\n}\n\nn_tot = org.get_repos().totalCount\n\nfor ii, repo in enumerate(org.get_repos()):\n    # check for existence of required files\n    # readme\n    try:\n        repo.get_contents('README.md')\n        readme = 1\n    except (UnknownObjectException, GithubException):\n        readme = 0\n    \n    # license\n    try:\n        repo.get_contents('LICENSE')\n        license = 1\n    except (UnknownObjectException, GithubException):\n        license = 0\n        \n    # contributing \n    try:\n        repo.get_contents('CONTRIBUTING.md')\n        contributing = 1\n    except (UnknownObjectException, GithubException):\n        contributing = 0\n        \n    try:\n        repo.get_contents('CODE_OF_CONDUCT.md')\n        coc = 1\n    except (UnknownObjectException, GithubException):\n        coc = 0\n        \n    files_dict['repo'].append(repo.name)\n    files_dict['readme'].append(readme)\n    files_dict['license'].append(license)\n    files_dict['contributing'].append(contributing)\n    files_dict['code_of_conduct'].append(coc)\n    \n    print(f'{ii+1:04}/{n_tot}', end='\\r')\n\n\n# re run from later when run out of requests per hour\nfor ii, repo in enumerate(org.get_repos()):\n    # check for existence of required files\n    # readme\n    if ii&gt;1452:\n        try:\n            repo.get_contents('README.md')\n            readme = 1\n        except (UnknownObjectException, GithubException):\n            readme = 0\n\n        # license\n        try:\n            repo.get_contents('LICENSE')\n            license = 1\n        except (UnknownObjectException, GithubException):\n            license = 0\n\n        # contributing \n        try:\n            repo.get_contents('CONTRIBUTING.md')\n            contributing = 1\n        except (UnknownObjectException, GithubException):\n            contributing = 0\n\n        try:\n            repo.get_contents('CODE_OF_CONDUCT.md')\n            coc = 1\n        except (UnknownObjectException, GithubException):\n            coc = 0\n\n        files_dict['repo'].append(repo.name)\n        files_dict['readme'].append(readme)\n        files_dict['license'].append(license)\n        files_dict['contributing'].append(contributing)\n        files_dict['code_of_conduct'].append(coc)\n\n        print(f'{ii+1:04}/{n_tot}', end='\\r')\n\n1920/1919\n\n\n\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n\ndf = pd.DataFrame(files_dict)\ndf['all_required'] = df.readme * df.contributing * df.license\ndf = df.drop_duplicates(ignore_index=True)\n\n\nout = df.agg(\n    {\n        'repo':'count',\n        'readme': 'sum',\n        'contributing': 'sum',\n        'license': 'sum',\n        'all_required': 'sum',\n        'code_of_conduct': 'sum'\n    }\n)\n\ncount = out.repo\n\nout.index = ['repo', 'README', 'CONTRIBUTING', 'LICENSE', 'ALL REQUIRED', 'CODE OF CONDUCT']\nout = pd.DataFrame(out).reset_index()\nout.columns = ['name', 'count']\n\nout['pct'] = out['count']/count\nout['end_pct'] = 1-out['pct']\nout['end_count'] = count - out['count']\nout['pct_words'] = out['pct'].apply(lambda x: f'{x:0.1%}')\n\nout = out.sort_values(by='pct', ascending=True)\nout = out[out['name'] != 'repo']\nout\n\n\n\n\n\n\n\n\nname\ncount\npct\nend_pct\nend_count\npct_words\n\n\n\n\n5\nCODE OF CONDUCT\n492\n0.256250\n0.743750\n1428\n25.6%\n\n\n4\nALL REQUIRED\n567\n0.295312\n0.704688\n1353\n29.5%\n\n\n2\nCONTRIBUTING\n629\n0.327604\n0.672396\n1291\n32.8%\n\n\n3\nLICENSE\n1605\n0.835938\n0.164062\n315\n83.6%\n\n\n1\nREADME\n1765\n0.919271\n0.080729\n155\n91.9%\n\n\n\n\n\n\n\n\nwith plt.xkcd():\n    plt.barh(\n        y = out['name'],\n        width = out['count'],\n        label = 'Present'\n    )\n    plt.barh(\n        y = out['name'],\n        width = out['end_count'],\n        left = out['count'],\n        label = 'Not Present'\n    )\n    \n    for ii in range(0,5):\n        plt.text(\n            x = 100,\n            y = ii-0.1,\n            s = out['pct_words'].values[ii]\n        )\n    \n    plt.xlim([0,1920])\n    plt.legend(loc='upper center', ncol=2, bbox_to_anchor = (0.5, 1.1))\n    \n    plt.savefig('figures/required_files.png', bbox_inches='tight')\n    plt.show()"
  },
  {
    "objectID": "materials/02-working-local.html",
    "href": "materials/02-working-local.html",
    "title": "2. Working Locally with Git",
    "section": "",
    "text": "Scenario: Wolfman and Dracula have been hired to investigate if it is possible to send a planetary lander to Mars. They want to be able to make notes and collect some data together, but have run into problems doing this in the past. If they take turns, each one will spend a lot of time waiting for the other to finish, but if they work on their own copies and email changes back and forth things will be lost, overwritten, or duplicated. Therefore, they are going to use Git with Github to work on their plans at the same time, then merge their changes\nFirst, let’s create a new directory on the C drive for our work. Your user profile on the C drive is the best place to create a repository for now. Git does not know how to reconcile the H drive as a “safe” place for our work. We will start by opening a git bash terminal, changing to the C: drive, creating a new directory, and changing the current working directory to the newly created one:\n$ cd c:/users/bashcrof\n$ mkdir planets\n$ cd planets\n\n\n\n\n\n\nAn aside on bash jargon\n\n\n\n\n\nGit is, at its core, a command line set of tools. While there are tips, tools and tricks to use Git via a graphical interface, this often hides the core functionality of what Git is really doing ‘behind the scenes.’ This is why we choose to introduce Git in its purest form. Unfortunately, this means that some familiarity with the command line is needed. Luckily, the amount required to understand is minimal!\nTo work our way through a git repository, we only need to access three main bash commands. These are all associated with moving the current working directory that is associated with your open git bash terminal.\n\ncd: This command allows us to move the current working directory associated with the open bash terminal to a new directory. It can be used in the following ways:\n\n$ cd path/to/directory       # Go to specified directory - \"quotes\" are needed if there are spaces in the path\n$ cd ..                      # Go up one directory level\n\nmkdir: This command allows us to create a new directory within the current working directory. It is used by specifying the name of the new directory.\n\n$ mkdir new_directory        # Create specified directory\n\nls: This command allows us to inspect the contents of the current working directory. It can be used in the following ways:\n\n$ ls                         # List directories and files\n$ ls -a                      # List directories and files, including hidden\nNote that if you are ever unsure of which working directory you are in, it should be visible as part of the command prompt. If not visible, you can request it via the pwd bash command.\n\n\n\nThe command line, and current working directory.\n\n\nOne final note on command lines. For Windows computers, to paste any line into the open terminal, Ctrl + v sadly won’t work. Instead, you use Shift + Insert. For OSX, Command + v should still work.\n\n\n\n\n\n\n\n\n\nOrienting yourself to bash\n\n\n\nIt is often useful to keep a File Explorer instance open while you are first learning to navigate through the world of the command line. This allows you to see, in real time, the new directories and files you are creating from the command line.\nIf you get lost, you can also use File Explorer to open a Git bash terminal directly in the folder we wish to work in. Simply navigate to the parent folder, right click on the folder you wish to work in, and click Open Git Bash here.\n\n\n\n\n\nNew folder in the user/username directory.\n\n\nThen we tell Git to make planets a repository – a place where Git can store versions of our files:\n$ git init\nIt is important to note that git init will create a repository that can include subdirectories and their files—there is no need to create separate repositories nested within the planets repository, whether subdirectories are present from the beginning or added later. Also, note that the creation of the planets directory and its initialization as a repository are completely separate processes.\nIf we use ls to show the directory’s contents, it appears that nothing has changed:\n$ ls\nBut if we add the -a flag to show everything, we can see that Git has created a hidden directory within planets called .git:\n$ ls -a\nWe get the following output:\n.   ..  .git\n\n\n\nWe can see the hidden folder in Folder Explorer as well.\n\n\nGit uses this special subdirectory to store all the information about the project, including the tracked files and sub-directories located within the project’s directory. If we ever delete the .gitsubdirectory, we will lose the project’s history.\nNext, we will change the default branch to be called main. This might be the default branch depending on your settings and version of git. See the setup episode for more information on this change.\n\n$ git branch -m main\n\nWe can check that everything is set up correctly by asking Git to tell us the status of our project:\n\n$ git status\n\nWe get the following output:\nOn branch main\n\nNo commits yet\n\nnothing to commit (create/copy files and use \"git add\" to track)\nIf you are using a different version of git, the exact wording of the output might be slightly different.\n\n\n\nFirst let’s make sure we’re still in the right directory. You should be in the planets directory.\n$ cd c:/users/bashcrof/planets\nNote that you can also tell you are in a Git repository, and not a regular directory, from the Git Bash command prompt. The very last part of the prompt (before the $) should contain, in brackets, the name of the branch we are on. Don’t worry about branches right now, but having main present in the command prompt tells us we are in a Git repository!\n\n\n\nRepository vs Directory.\n\n\nLet’s create a file called mars.txt that contains some notes about the Red Planet’s suitability as a base. Open a new document named mars.txt using a plain text editor such as Notepad++. Add the following line to mars.txt and save the file.\nCold and dry, but everything is my favorite color\n\n\n\n\n\n\nTo bash or not to bash?\n\n\n\nNote that while Git itself is inherently a command line program, the rest of the files we create within our repository do not have to be made in the same way! We can create subfolders, add documents, code, etc. using our favourite tools. This may be Microsoft Word, VS Code, RStudio, or even vim for the hard core. Once the new items have been added, head back to the git bash terminal to do any Git command magic necessary.\n\n\nAfter switching back to the GitBash command-line interface, let’s verify that the file was properly created by running the list command (ls):\n$ ls\nWe should see the following file in our directory:\nmars.txt\nIf we check the status of our project again, Git tells us that it’s noticed the new file:\n\n$ git status\n\nOn branch main\n\nNo commits yet\n\nUntracked files:\n   (use \"git add &lt;file&gt;...\" to include in what will be committed)\n\n    mars.txt\n\nnothing added to commit but untracked files present (use \"git add\" to track)\nThe “untracked files” message means that there’s a file in the directory that Git isn’t keeping track of. We can tell Git to track a file using git add:\n$ git add mars.txt\nand then check that the right thing happened:\n\n$ git status\n\nOn branch main\n\nNo commits yet\n\nChanges to be committed:\n  (use \"git rm --cached &lt;file&gt;...\" to unstage)\n\n    new file:   mars.txt\n\n\n\nGit now knows that it’s supposed to keep track of mars.txt, but it hasn’t recorded these changes as a commit yet. To get it to do that, we need to run one more command:\n\n$ git commit -m \"Start notes on Mars as a base\"\n\n[main (root-commit) f22b25e] Start notes on Mars as a base\n 1 file changed, 1 insertion(+)\n create mode 100644 mars.txt\nWhen we run git commit, Git takes everything we have told it to save by using git add and stores a copy permanently inside the special .git directory. This permanent copy is called a commit (or revision) and its short identifier is f22b25e. Your commit may have another identifier.\nWe use the -m flag (for “message”) to record a short, descriptive, and specific comment that will help us remember later on what we did and why.\n\n\n\n\n\n\nNote\n\n\n\nIf we just run git commit without the -m option, Git will launch a utility program called nano  and ask us to write a longer message. If this happens, click CTRL+X to go back to the command line and run git commit -m \"your commit message\".\n\n\n\n\n\n\n\n\nNote\n\n\n\nGood commit messages start with a brief (&lt;50 characters) statement about the changes made in the commit. Generally, the message should complete the sentence “If applied, this commit will” . If you want to go into more detail, add a blank line between the summary line and your additional notes. Use this additional space to explain why you made changes and/or what their impact will be.\n\n\nIf we run git status now:\n\n$ git status\n\nOn branch main\nnothing to commit, working tree clean\nit tells us everything is up to date.\n\n\n\nIf we want to know what we’ve done recently, we can ask Git to show us the project’s history using git log:\n\n$ git log\n\ncommit f22b25e3233b4645dabd0d81e651fe074bd8e73b\nAuthor: Vlad Dracula &lt;vlad@tran.sylvan.ia&gt;\nDate:   Thu Aug 22 09:51:46 2013 -0400\n\n    Start notes on Mars as a base\ngit log lists all commits made to a repository in reverse chronological order. The listing for each commit includes the commit’s full identifier (which starts with the same characters as the short identifier printed by the git commit command earlier), the commit’s author, when it was created, and the log message Git was given when the commit was created.\nLet’s add more information to the file. Again, open up your text editor to add and save your changes. Switch back to command line when you’re finished.\nmars.txt contains a new line, which we can verify by running:\n\n$ cat mars.txt\n\nCold and dry, but everything is my favorite color\nThe two moons may be a problem for Wolfman\nWhen we run git status now, it tells us that a file it already knows about has been modified:\n\n$ git status\n\nOn branch main\nChanges not staged for commit:\n  (use \"git add &lt;file&gt;...\" to update what will be committed)\n  (use \"git checkout -- &lt;file&gt;...\" to discard changes in working directory)\n\n    modified:   mars.txt\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\nThe last line is the key phrase: “no changes added to commit”. We have changed this file, but we haven’t told Git we will want to save those changes (which we do with git add) nor have we saved them (which we do with git commit).\nTo explicitly identify what has changed between the last commit and any new, unstaged changes, we may use the git diff command. This will show us a list of what has changed between the most recent commit (the ‘HEAD’) and our local (but unstaged) changes for a given file (mars.txt).\n$ git diff HEAD mars.txt\ndiff --git a/test.txt b/test.txt\nindex df0654a..c73b558 100644\n--- a/mars.txt\n+++ b/mars.txt\n@@ -1 +1,3 @@\n Cold and dry, but everything is my favorite color\n+The two moons may be a problem for Wolfman.\nAfter reviewing our change, it’s time to commit it:\n\n$ git add mars.txt\n$ git commit -m \"Add concerns about effects of Mars' moons on Wolfman\"\n\n[main 34961b1] Add concerns about effects of Mars' moons on Wolfman\n 1 file changed, 1 insertion(+)\nFinally, we may have made multiple changes to a file that cause it to stop working as intended. This is incredibly common with code scripts, such as .r or .py files. More often than not, it can be incredibly difficult to identify what has actually broken, and we wish to simply revert to a copy of the code where we know that things were working as intended. This is one place that version control really shines. Let’s add another line to our mars.txt file to simulate a ‘broken’ code script:\n$ cat mars.txt\nCold and dry, but everything is my favorite color\nThe two moons may be a problem for Wolfman\nTHIS LINE BREAKS EVERYTHING OH NO.\nIn order to revert the ‘broken’ script to a working version, we can use the git restore command:\ngit restore mars.txt\ncat mars.txt\nCold and dry, but everything is my favorite color\nThe two moons may be a problem for Wolfman\n\n\n\nAs a final note, Git insists that we add files to the set we want to commit before actually committing anything. This allows us to commit our changes in stages and capture changes in logical portions rather than only large batches. For example, suppose we’re adding a few citations to relevant research to our thesis. We might want to commit those additions, and the corresponding bibliography entries, but not commit some of our work drafting the conclusion (which we haven’t finished yet).\nTo allow for this, Git has a special staging area where it keeps track of things that have been added to the current changeset but not yet committed.\nIf you think of Git as taking snapshots of changes over the life of a project, git add specifies what will go in a snapshot (putting things in the staging area), and git commit then actually takes the snapshot, and makes a permanent record of it (as a commit). If you don’t have anything staged when you type git commit, Git will prompt you to use git commit -a or git commit –all, which is kind of like gathering everyone to take a group photo! However, it’s almost always better to explicitly add things to the staging area, because you might commit changes you forgot you made. (Going back to the group photo simile, you might get an extra with incomplete makeup walking on the stage for the picture because you used -a!) Try to stage things manually, or you might find yourself searching for “git undo commit” more than you would like!\n\n\n\nThe Git Staging Area",
    "crumbs": [
      "About",
      "Course Sections",
      "2. Working Locally with Git"
    ]
  },
  {
    "objectID": "materials/02-working-local.html#creating-a-repository",
    "href": "materials/02-working-local.html#creating-a-repository",
    "title": "2. Working Locally with Git",
    "section": "",
    "text": "Scenario: Wolfman and Dracula have been hired to investigate if it is possible to send a planetary lander to Mars. They want to be able to make notes and collect some data together, but have run into problems doing this in the past. If they take turns, each one will spend a lot of time waiting for the other to finish, but if they work on their own copies and email changes back and forth things will be lost, overwritten, or duplicated. Therefore, they are going to use Git with Github to work on their plans at the same time, then merge their changes\nFirst, let’s create a new directory on the C drive for our work. Your user profile on the C drive is the best place to create a repository for now. Git does not know how to reconcile the H drive as a “safe” place for our work. We will start by opening a git bash terminal, changing to the C: drive, creating a new directory, and changing the current working directory to the newly created one:\n$ cd c:/users/bashcrof\n$ mkdir planets\n$ cd planets\n\n\n\n\n\n\nAn aside on bash jargon\n\n\n\n\n\nGit is, at its core, a command line set of tools. While there are tips, tools and tricks to use Git via a graphical interface, this often hides the core functionality of what Git is really doing ‘behind the scenes.’ This is why we choose to introduce Git in its purest form. Unfortunately, this means that some familiarity with the command line is needed. Luckily, the amount required to understand is minimal!\nTo work our way through a git repository, we only need to access three main bash commands. These are all associated with moving the current working directory that is associated with your open git bash terminal.\n\ncd: This command allows us to move the current working directory associated with the open bash terminal to a new directory. It can be used in the following ways:\n\n$ cd path/to/directory       # Go to specified directory - \"quotes\" are needed if there are spaces in the path\n$ cd ..                      # Go up one directory level\n\nmkdir: This command allows us to create a new directory within the current working directory. It is used by specifying the name of the new directory.\n\n$ mkdir new_directory        # Create specified directory\n\nls: This command allows us to inspect the contents of the current working directory. It can be used in the following ways:\n\n$ ls                         # List directories and files\n$ ls -a                      # List directories and files, including hidden\nNote that if you are ever unsure of which working directory you are in, it should be visible as part of the command prompt. If not visible, you can request it via the pwd bash command.\n\n\n\nThe command line, and current working directory.\n\n\nOne final note on command lines. For Windows computers, to paste any line into the open terminal, Ctrl + v sadly won’t work. Instead, you use Shift + Insert. For OSX, Command + v should still work.\n\n\n\n\n\n\n\n\n\nOrienting yourself to bash\n\n\n\nIt is often useful to keep a File Explorer instance open while you are first learning to navigate through the world of the command line. This allows you to see, in real time, the new directories and files you are creating from the command line.\nIf you get lost, you can also use File Explorer to open a Git bash terminal directly in the folder we wish to work in. Simply navigate to the parent folder, right click on the folder you wish to work in, and click Open Git Bash here.\n\n\n\n\n\nNew folder in the user/username directory.\n\n\nThen we tell Git to make planets a repository – a place where Git can store versions of our files:\n$ git init\nIt is important to note that git init will create a repository that can include subdirectories and their files—there is no need to create separate repositories nested within the planets repository, whether subdirectories are present from the beginning or added later. Also, note that the creation of the planets directory and its initialization as a repository are completely separate processes.\nIf we use ls to show the directory’s contents, it appears that nothing has changed:\n$ ls\nBut if we add the -a flag to show everything, we can see that Git has created a hidden directory within planets called .git:\n$ ls -a\nWe get the following output:\n.   ..  .git\n\n\n\nWe can see the hidden folder in Folder Explorer as well.\n\n\nGit uses this special subdirectory to store all the information about the project, including the tracked files and sub-directories located within the project’s directory. If we ever delete the .gitsubdirectory, we will lose the project’s history.\nNext, we will change the default branch to be called main. This might be the default branch depending on your settings and version of git. See the setup episode for more information on this change.\n\n$ git branch -m main\n\nWe can check that everything is set up correctly by asking Git to tell us the status of our project:\n\n$ git status\n\nWe get the following output:\nOn branch main\n\nNo commits yet\n\nnothing to commit (create/copy files and use \"git add\" to track)\nIf you are using a different version of git, the exact wording of the output might be slightly different.",
    "crumbs": [
      "About",
      "Course Sections",
      "2. Working Locally with Git"
    ]
  },
  {
    "objectID": "materials/02-working-local.html#tracking-files",
    "href": "materials/02-working-local.html#tracking-files",
    "title": "2. Working Locally with Git",
    "section": "",
    "text": "First let’s make sure we’re still in the right directory. You should be in the planets directory.\n$ cd c:/users/bashcrof/planets\nNote that you can also tell you are in a Git repository, and not a regular directory, from the Git Bash command prompt. The very last part of the prompt (before the $) should contain, in brackets, the name of the branch we are on. Don’t worry about branches right now, but having main present in the command prompt tells us we are in a Git repository!\n\n\n\nRepository vs Directory.\n\n\nLet’s create a file called mars.txt that contains some notes about the Red Planet’s suitability as a base. Open a new document named mars.txt using a plain text editor such as Notepad++. Add the following line to mars.txt and save the file.\nCold and dry, but everything is my favorite color\n\n\n\n\n\n\nTo bash or not to bash?\n\n\n\nNote that while Git itself is inherently a command line program, the rest of the files we create within our repository do not have to be made in the same way! We can create subfolders, add documents, code, etc. using our favourite tools. This may be Microsoft Word, VS Code, RStudio, or even vim for the hard core. Once the new items have been added, head back to the git bash terminal to do any Git command magic necessary.\n\n\nAfter switching back to the GitBash command-line interface, let’s verify that the file was properly created by running the list command (ls):\n$ ls\nWe should see the following file in our directory:\nmars.txt\nIf we check the status of our project again, Git tells us that it’s noticed the new file:\n\n$ git status\n\nOn branch main\n\nNo commits yet\n\nUntracked files:\n   (use \"git add &lt;file&gt;...\" to include in what will be committed)\n\n    mars.txt\n\nnothing added to commit but untracked files present (use \"git add\" to track)\nThe “untracked files” message means that there’s a file in the directory that Git isn’t keeping track of. We can tell Git to track a file using git add:\n$ git add mars.txt\nand then check that the right thing happened:\n\n$ git status\n\nOn branch main\n\nNo commits yet\n\nChanges to be committed:\n  (use \"git rm --cached &lt;file&gt;...\" to unstage)\n\n    new file:   mars.txt",
    "crumbs": [
      "About",
      "Course Sections",
      "2. Working Locally with Git"
    ]
  },
  {
    "objectID": "materials/02-working-local.html#committing-changes",
    "href": "materials/02-working-local.html#committing-changes",
    "title": "2. Working Locally with Git",
    "section": "",
    "text": "Git now knows that it’s supposed to keep track of mars.txt, but it hasn’t recorded these changes as a commit yet. To get it to do that, we need to run one more command:\n\n$ git commit -m \"Start notes on Mars as a base\"\n\n[main (root-commit) f22b25e] Start notes on Mars as a base\n 1 file changed, 1 insertion(+)\n create mode 100644 mars.txt\nWhen we run git commit, Git takes everything we have told it to save by using git add and stores a copy permanently inside the special .git directory. This permanent copy is called a commit (or revision) and its short identifier is f22b25e. Your commit may have another identifier.\nWe use the -m flag (for “message”) to record a short, descriptive, and specific comment that will help us remember later on what we did and why.\n\n\n\n\n\n\nNote\n\n\n\nIf we just run git commit without the -m option, Git will launch a utility program called nano  and ask us to write a longer message. If this happens, click CTRL+X to go back to the command line and run git commit -m \"your commit message\".\n\n\n\n\n\n\n\n\nNote\n\n\n\nGood commit messages start with a brief (&lt;50 characters) statement about the changes made in the commit. Generally, the message should complete the sentence “If applied, this commit will” . If you want to go into more detail, add a blank line between the summary line and your additional notes. Use this additional space to explain why you made changes and/or what their impact will be.\n\n\nIf we run git status now:\n\n$ git status\n\nOn branch main\nnothing to commit, working tree clean\nit tells us everything is up to date.",
    "crumbs": [
      "About",
      "Course Sections",
      "2. Working Locally with Git"
    ]
  },
  {
    "objectID": "materials/02-working-local.html#viewing-and-restoring-the-commit-history",
    "href": "materials/02-working-local.html#viewing-and-restoring-the-commit-history",
    "title": "2. Working Locally with Git",
    "section": "",
    "text": "If we want to know what we’ve done recently, we can ask Git to show us the project’s history using git log:\n\n$ git log\n\ncommit f22b25e3233b4645dabd0d81e651fe074bd8e73b\nAuthor: Vlad Dracula &lt;vlad@tran.sylvan.ia&gt;\nDate:   Thu Aug 22 09:51:46 2013 -0400\n\n    Start notes on Mars as a base\ngit log lists all commits made to a repository in reverse chronological order. The listing for each commit includes the commit’s full identifier (which starts with the same characters as the short identifier printed by the git commit command earlier), the commit’s author, when it was created, and the log message Git was given when the commit was created.\nLet’s add more information to the file. Again, open up your text editor to add and save your changes. Switch back to command line when you’re finished.\nmars.txt contains a new line, which we can verify by running:\n\n$ cat mars.txt\n\nCold and dry, but everything is my favorite color\nThe two moons may be a problem for Wolfman\nWhen we run git status now, it tells us that a file it already knows about has been modified:\n\n$ git status\n\nOn branch main\nChanges not staged for commit:\n  (use \"git add &lt;file&gt;...\" to update what will be committed)\n  (use \"git checkout -- &lt;file&gt;...\" to discard changes in working directory)\n\n    modified:   mars.txt\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\nThe last line is the key phrase: “no changes added to commit”. We have changed this file, but we haven’t told Git we will want to save those changes (which we do with git add) nor have we saved them (which we do with git commit).\nTo explicitly identify what has changed between the last commit and any new, unstaged changes, we may use the git diff command. This will show us a list of what has changed between the most recent commit (the ‘HEAD’) and our local (but unstaged) changes for a given file (mars.txt).\n$ git diff HEAD mars.txt\ndiff --git a/test.txt b/test.txt\nindex df0654a..c73b558 100644\n--- a/mars.txt\n+++ b/mars.txt\n@@ -1 +1,3 @@\n Cold and dry, but everything is my favorite color\n+The two moons may be a problem for Wolfman.\nAfter reviewing our change, it’s time to commit it:\n\n$ git add mars.txt\n$ git commit -m \"Add concerns about effects of Mars' moons on Wolfman\"\n\n[main 34961b1] Add concerns about effects of Mars' moons on Wolfman\n 1 file changed, 1 insertion(+)\nFinally, we may have made multiple changes to a file that cause it to stop working as intended. This is incredibly common with code scripts, such as .r or .py files. More often than not, it can be incredibly difficult to identify what has actually broken, and we wish to simply revert to a copy of the code where we know that things were working as intended. This is one place that version control really shines. Let’s add another line to our mars.txt file to simulate a ‘broken’ code script:\n$ cat mars.txt\nCold and dry, but everything is my favorite color\nThe two moons may be a problem for Wolfman\nTHIS LINE BREAKS EVERYTHING OH NO.\nIn order to revert the ‘broken’ script to a working version, we can use the git restore command:\ngit restore mars.txt\ncat mars.txt\nCold and dry, but everything is my favorite color\nThe two moons may be a problem for Wolfman",
    "crumbs": [
      "About",
      "Course Sections",
      "2. Working Locally with Git"
    ]
  },
  {
    "objectID": "materials/02-working-local.html#the-staging-area",
    "href": "materials/02-working-local.html#the-staging-area",
    "title": "2. Working Locally with Git",
    "section": "",
    "text": "As a final note, Git insists that we add files to the set we want to commit before actually committing anything. This allows us to commit our changes in stages and capture changes in logical portions rather than only large batches. For example, suppose we’re adding a few citations to relevant research to our thesis. We might want to commit those additions, and the corresponding bibliography entries, but not commit some of our work drafting the conclusion (which we haven’t finished yet).\nTo allow for this, Git has a special staging area where it keeps track of things that have been added to the current changeset but not yet committed.\nIf you think of Git as taking snapshots of changes over the life of a project, git add specifies what will go in a snapshot (putting things in the staging area), and git commit then actually takes the snapshot, and makes a permanent record of it (as a commit). If you don’t have anything staged when you type git commit, Git will prompt you to use git commit -a or git commit –all, which is kind of like gathering everyone to take a group photo! However, it’s almost always better to explicitly add things to the staging area, because you might commit changes you forgot you made. (Going back to the group photo simile, you might get an extra with incomplete makeup walking on the stage for the picture because you used -a!) Try to stage things manually, or you might find yourself searching for “git undo commit” more than you would like!\n\n\n\nThe Git Staging Area",
    "crumbs": [
      "About",
      "Course Sections",
      "2. Working Locally with Git"
    ]
  },
  {
    "objectID": "materials/01-what-is-vc.html",
    "href": "materials/01-what-is-vc.html",
    "title": "1. What is Version Control",
    "section": "",
    "text": "https://phdcomics.com/comics.php?f=1531\n\n\nNot this.\n\n\nVersion control, also known as source control, is the practice of tracking and managing changes to software code. Version control systems are software tools that are used to help individuals and software development teams manage changes to code/documents over time.\nConsider the following scenario. You and your colleagues have been asked to do an analysis of the Work Environment Survey study to determine if workplace satisfaction has increased or decreased significantly since the start of the pandemic. You and your colleagues want to be able to work on the project at the same time, but have run into problems doing this in the past. If you take turns, each of you will spend a lot of time waiting for the other to finish, but if you work on your own copies and save them to the local network, things will be lost, overwritten, or duplicated. A colleague suggests using version control to manage your work.\nWe’ve all been in this situation before: it seems unnecessary to have multiple nearly-identical versions of the same document. Some word processors let us deal with this a little better, such as Microsoft Word’s Track Changes and Google Docs’ version history.\nVersion control systems start with a base version of the document and then record changes you make each step of the way. You can think of it as a recording of your progress: you can rewind to start at the base document and play back each change you made, eventually arriving at your more recent version.\n\n\n\nChanges Are Saved Sequentially\n\n\nOnce you think of changes as separate from the document itself, you can then think about “playing back” different sets of changes on the base document, ultimately resulting in different versions of that document. For example, two users can make independent sets of changes on the same document.\n\n\n\nDifferent Versions Can be Saved and Merged\n\n\nUnless multiple users make changes to the same section of the document - a conflict - you can incorporate two sets of changes into the same base document.\nA version control system is a tool that keeps track of these changes for us, effectively creating different versions of our files. It allows us to decide which changes will be made to the next version (each record of these changes is called a commit), and keeps useful metadata about them. The complete history of commits for a particular project and their metadata make up a repository. Repositories can be kept in sync across different computers, facilitating collaboration among different people.\n\n\n\nVersion control is the lab notebook of the digital world: it’s what professionals use to keep track of what they’ve done and to collaborate with other people.\nVersion control is better than sharing files back and forth because:\n\nNothing that is committed to version control is ever lost, unless you work really, really hard at it. Since all old versions of files are saved, it’s always possible to go back in time to see exactly who wrote what on a particular day, or what version of a program was used to generate a particular set of results.\nAs we have this record of who made what changes when, we know who to ask if we have questions later on, and, if needed, revert to a previous version, much like the “undo” feature in an editor.\nWhen several people collaborate in the same project, it’s possible to accidentally overlook or overwrite someone’s changes. The version control system automatically notifies users whenever there’s a conflict between one person’s work and another’s.\n\n\n\n\n\n\n\nNote\n\n\n\nTeams are not the only ones to benefit from version control: lone researchers can benefit immensely. Keeping a record of what was changed, when, and why is extremely useful for all researchers if they ever need to come back to the project later on (e.g., a year later, when memory has faded).\n\n\n\n\n\n\n\n\nRelated Reading\n\n\n\nExcuse me, do you have a moment to talk about version control? Jenny Bryan https://peerj.com/preprints/3159/\n\n\n\n\n\nIn version control systems, a repository is a data structure that stores metadata for a set of files or directory structure. Some of the metadata that a repository contains includes, among other things, a historical record of changes in the repository, a set of commit objects, and a set of references to commit objects, called heads.\nEssentially, a version control repository keeps track of a set of files in a project. It is like a regular project folder containing sub folders to organize your work, but with an additional .git folder in which to house metadata. We will go into more detail on how the .git folder and metadata files are created during the workshop.\nUsing the WES analysis example above, you and your colleagues may choose to structure your version control project like this:\n├── wes-analysis\n|   ├── data    \n|   │   ├── wes-results\n|   │   │   ├── wes-results-2019.csv  &lt;-- DON'T WORRY, THESE WON'T BECOME PUBLIC!\n|   │   │   ├── wes-results-2020.csv\n|   │   │   ├── wes-results-2021.csv\n|   │   |   |── wes-results-2022.csv\n|   ├── doc\n|   ├── ref\n|   │   ├── references\n|   │   ├── images\n|   ├── plots\n|   ├── code\n|   ├── .git      &lt;------------------------ THIS MAKES IT A GIT REPOSITORY!\n|   ├── .gitignore &lt;-------------- FILES listed here are ignored by git (not tracked, e.g., csv files)",
    "crumbs": [
      "About",
      "Course Sections",
      "1. What is Version Control"
    ]
  },
  {
    "objectID": "materials/01-what-is-vc.html#what-is-version-control-1",
    "href": "materials/01-what-is-vc.html#what-is-version-control-1",
    "title": "1. What is Version Control",
    "section": "",
    "text": "Version control, also known as source control, is the practice of tracking and managing changes to software code. Version control systems are software tools that are used to help individuals and software development teams manage changes to code/documents over time.\nConsider the following scenario. You and your colleagues have been asked to do an analysis of the Work Environment Survey study to determine if workplace satisfaction has increased or decreased significantly since the start of the pandemic. You and your colleagues want to be able to work on the project at the same time, but have run into problems doing this in the past. If you take turns, each of you will spend a lot of time waiting for the other to finish, but if you work on your own copies and save them to the local network, things will be lost, overwritten, or duplicated. A colleague suggests using version control to manage your work.\nWe’ve all been in this situation before: it seems unnecessary to have multiple nearly-identical versions of the same document. Some word processors let us deal with this a little better, such as Microsoft Word’s Track Changes and Google Docs’ version history.\nVersion control systems start with a base version of the document and then record changes you make each step of the way. You can think of it as a recording of your progress: you can rewind to start at the base document and play back each change you made, eventually arriving at your more recent version.\n\n\n\nChanges Are Saved Sequentially\n\n\nOnce you think of changes as separate from the document itself, you can then think about “playing back” different sets of changes on the base document, ultimately resulting in different versions of that document. For example, two users can make independent sets of changes on the same document.\n\n\n\nDifferent Versions Can be Saved and Merged\n\n\nUnless multiple users make changes to the same section of the document - a conflict - you can incorporate two sets of changes into the same base document.\nA version control system is a tool that keeps track of these changes for us, effectively creating different versions of our files. It allows us to decide which changes will be made to the next version (each record of these changes is called a commit), and keeps useful metadata about them. The complete history of commits for a particular project and their metadata make up a repository. Repositories can be kept in sync across different computers, facilitating collaboration among different people.",
    "crumbs": [
      "About",
      "Course Sections",
      "1. What is Version Control"
    ]
  },
  {
    "objectID": "materials/01-what-is-vc.html#why-version-control",
    "href": "materials/01-what-is-vc.html#why-version-control",
    "title": "1. What is Version Control",
    "section": "",
    "text": "Version control is the lab notebook of the digital world: it’s what professionals use to keep track of what they’ve done and to collaborate with other people.\nVersion control is better than sharing files back and forth because:\n\nNothing that is committed to version control is ever lost, unless you work really, really hard at it. Since all old versions of files are saved, it’s always possible to go back in time to see exactly who wrote what on a particular day, or what version of a program was used to generate a particular set of results.\nAs we have this record of who made what changes when, we know who to ask if we have questions later on, and, if needed, revert to a previous version, much like the “undo” feature in an editor.\nWhen several people collaborate in the same project, it’s possible to accidentally overlook or overwrite someone’s changes. The version control system automatically notifies users whenever there’s a conflict between one person’s work and another’s.\n\n\n\n\n\n\n\nNote\n\n\n\nTeams are not the only ones to benefit from version control: lone researchers can benefit immensely. Keeping a record of what was changed, when, and why is extremely useful for all researchers if they ever need to come back to the project later on (e.g., a year later, when memory has faded).\n\n\n\n\n\n\n\n\nRelated Reading\n\n\n\nExcuse me, do you have a moment to talk about version control? Jenny Bryan https://peerj.com/preprints/3159/",
    "crumbs": [
      "About",
      "Course Sections",
      "1. What is Version Control"
    ]
  },
  {
    "objectID": "materials/01-what-is-vc.html#what-is-a-version-control-repository",
    "href": "materials/01-what-is-vc.html#what-is-a-version-control-repository",
    "title": "1. What is Version Control",
    "section": "",
    "text": "In version control systems, a repository is a data structure that stores metadata for a set of files or directory structure. Some of the metadata that a repository contains includes, among other things, a historical record of changes in the repository, a set of commit objects, and a set of references to commit objects, called heads.\nEssentially, a version control repository keeps track of a set of files in a project. It is like a regular project folder containing sub folders to organize your work, but with an additional .git folder in which to house metadata. We will go into more detail on how the .git folder and metadata files are created during the workshop.\nUsing the WES analysis example above, you and your colleagues may choose to structure your version control project like this:\n├── wes-analysis\n|   ├── data    \n|   │   ├── wes-results\n|   │   │   ├── wes-results-2019.csv  &lt;-- DON'T WORRY, THESE WON'T BECOME PUBLIC!\n|   │   │   ├── wes-results-2020.csv\n|   │   │   ├── wes-results-2021.csv\n|   │   |   |── wes-results-2022.csv\n|   ├── doc\n|   ├── ref\n|   │   ├── references\n|   │   ├── images\n|   ├── plots\n|   ├── code\n|   ├── .git      &lt;------------------------ THIS MAKES IT A GIT REPOSITORY!\n|   ├── .gitignore &lt;-------------- FILES listed here are ignored by git (not tracked, e.g., csv files)",
    "crumbs": [
      "About",
      "Course Sections",
      "1. What is Version Control"
    ]
  },
  {
    "objectID": "pre-workshop/software-install.html#create-your-github-account",
    "href": "pre-workshop/software-install.html#create-your-github-account",
    "title": "Installation Instructions and Set-Up",
    "section": "1 Create your GitHub Account",
    "text": "1 Create your GitHub Account\nAs part of this workshop we will be connecting and pushing some sample code to GitHub, therefore you’ll need to create a GitHub account. In general, creating a GitHub account can be a great way to collaborate on open-source projects, showcase your work, and learn from others.\n\nGo to https://github.com and click “Sign up” at the top-right of the window.\n\nNote that this does NOT have to be your BC gov email (but if you want one just for government use, feel free to use your BC gov email).\nIf you already have a personal GitHub account, that is just fine! This can be connected to your BC gov email at a later date.\n\nFollow the step-by-step instructions to create an account.\nVerify your email address with GitHub.\n\nOptional reading: Configuring your GitHub account"
  },
  {
    "objectID": "pre-workshop/software-install.html#login-to-your-github-account",
    "href": "pre-workshop/software-install.html#login-to-your-github-account",
    "title": "Installation Instructions and Set-Up",
    "section": "2 Login to your GitHub Account",
    "text": "2 Login to your GitHub Account\nWhen we sign in to GitHub on the web, we are signing into our application account created in step 1. This is where we manage our profile settings, set our passwords, and browse repositories. It is possible to edit repository content from GitHub although editing is often performed in a local application such as RStudio, VS Code or a text editor. We will go into more detail on that in the course workshop.\n\nGo to https://github.com/ and click “Sign In” (top right corner).\n\nEnter either your username or your email address, and password created in Step 1."
  },
  {
    "objectID": "pre-workshop/software-install.html#configure-multi-factor-authentication-2fa",
    "href": "pre-workshop/software-install.html#configure-multi-factor-authentication-2fa",
    "title": "Installation Instructions and Set-Up",
    "section": "3 Configure Multi-Factor authentication (2FA)",
    "text": "3 Configure Multi-Factor authentication (2FA)\nAs of 2023 all GitHub accounts are required to have multi-factor authentication (2FA) configured for extra security. Several options exist for setting up 2FA, the simplest is via text message described below.\n\nIn the upper-right corner of any page, click on your profile photo/avatar and select Settings.\nIn the “Access” section of the sidebar, click on Password and authentication.\nScroll down to “Two-factor authentication” section of the page and click Enable two-factor authentication.\nAt the bottom of the page, next to “SMS authentication”, click Select.\nComplete the CAPTCHA challenge, which helps protect against spam and abuse.\nUnder “Setup SMS authentication”, select your country code and type your mobile phone number, including the area code. When your information is correct, click Send authentication code.\nYou’ll receive a text message with a security code. On GitHub, type the code into the field under “Verify the code sent to your phone” and click Continue.\nIf you need to edit the phone number you entered, you’ll need to complete another CAPTCHA challenge.\nUnder “Save your recovery codes”, click Download to download your two-factor recovery codes to your device. Save them to a secure location because your recovery codes can help you get back into your account if you lose access.\nAfter saving your two-factor recovery codes, click “I have saved my recovery codes” to enable two-factor authentication for your account.\n\nOptional reading: Other 2FA configurations."
  },
  {
    "objectID": "pre-workshop/software-install.html#create-a-personal-access-token",
    "href": "pre-workshop/software-install.html#create-a-personal-access-token",
    "title": "Installation Instructions and Set-Up",
    "section": "4 Create a Personal Access Token",
    "text": "4 Create a Personal Access Token\nTo keep your account secure, you must authenticate before you can access certain resources on GitHub. When we access resources via a browser (as in Step 2) we are authenticating with our username and password and two-factor authentication. In the workshop we will also be accessing GitHub resources via the REST API. You can authenticate with the API in different ways, but the simplest way is with a Classic Personal Access Token (PAT).\nFirst verify your email address (if it hasn’t been verified yet):\n\nIn the upper-right corner of any page, click your profile photo, then click Settings.\nIn the “Access” section of the sidebar, click Emails.\nUnder your email address, click Resend verification email.\nGitHub will send you an email with a link in it. After you click that link, you’ll be taken to your GitHub dashboard and see a confirmation banner.\n\nThen create your PAT:\n\nIn the upper-right corner of any page, click your profile photo, then click Settings.\nIn the left sidebar, click Developer settings.\nIn the left sidebar, under Personal access tokens, click Tokens (classic).\nSelect Generate new token, then click Generate new token (classic).\nIn the “Note” field, give your token a descriptive name. At some point you may use a second PAT and a name helps keep things straight but for now you could name it “work-2023” or “november-2023”.\nTo give your token an expiration date, select Expiration. For first time users, 30 days is a good choice, after which time GitHub will send an email notification reminding you to renew your PAT.\nSelect the scopes you’d like to grant this token. The repo and user boxes should be sufficient for the workshop and most cases in general.\nClick Generate token.\nCopy the new token to your clipboard and save to a text file for later.\n\nOptional reading: Authenticating to the REST API"
  },
  {
    "objectID": "pre-workshop/software-install.html#install-git-and-gitbash",
    "href": "pre-workshop/software-install.html#install-git-and-gitbash",
    "title": "Installation Instructions and Set-Up",
    "section": "5 Install Git (and GitBash)",
    "text": "5 Install Git (and GitBash)\nGit is a set of command line utility programs that are designed to execute on a Unix style command-line environment. Linux and MacOS both include built-in Unix command line terminals. Most likely you are working on a Windows operating system and will require Git Bash, an application for Windows environments which provides an emulation layer for a Git command line experience.\n\nWindows\n\nSearch for “Git Bash” in your start menu to check if Git/GitBash are already installed on your computer.\nIf Git/GitBash are not installed, navigate to Git for Windows and click “Click here to download” to download the latest 64-bit version of Git for Windows software. This software includes GitBash\nAfter the download is complete, double click on it to run the installer. The Git Setup wizard will appear. Follow the on-screen prompts by clicking “Next” and “Finish” to complete the installation. The default options are suitable for most users with the following exceptions:\n\nSelect Notepad++, Notepad or Wordpad to use as your default editor.\nAdjust the name of the initial branch in new repositories. Override the default to use “main” instead of “master”.\n\n\n\n\nMacOS\nPlease visit: Installing Git and follow the instructions for installing git for MacOSX."
  },
  {
    "objectID": "pre-workshop/software-install.html#configure-git",
    "href": "pre-workshop/software-install.html#configure-git",
    "title": "Installation Instructions and Set-Up",
    "section": "6 Configure Git",
    "text": "6 Configure Git\n\n6.1 Git Set Up\nWhen we use Git on a new computer for the first time, we need to configure a few things. Below are a few examples of configurations we will set as we get started with Git:\n\nour name and email address\nand that we want to use these settings globally (i.e. for every project).\n\nOn a command line, Git commands are written as git verb options, where verb is what we actually want to do and options is additional optional information which may be needed for the verb.\n\n\n6.2 Set user.name & user.email\nIn this workshop, we’ll be working with GitHub, and it’s important to ensure that the name and email address you configure on your local computer matches the one associated with your GitHub account. For most participants, this will be your government email address.\nBelow is an example configuration that we will use to connect your local git instance with GitHub.\nFor Windows users, these will be typed into a Git Bash terminal (search for Git Bash from the search bar to open a new window). For Mac users, these will be typed into the Terminal.\n$ git config --global user.name \"your GitHub account name\" \n$ git config --global user.email \"your_email@gmail.com\"\nIf you are concerned about privacy, please review GitHub’s instructions for keeping your email address private.\n\n\n6.3 Check Global Settings\nThe two commands we just ran only need to be run once. The flag --global tells Git to use the settings for every project on this computer.\nYou can check your settings at any time with:\n$ git config --list\nYou can change your configuration as many times as you want: use the same commands to update your name or email address.\n\n\n6.4 Access Git Help and Manual\nIf you forget a git command, you can access a list of available commands by appending a -h. You can access the Git manual for a command by appending --help :\n$ git config -h\n$ git config --help\nWhile viewing the manual, you may see : near the cursor at the bottom of the screen. This is a prompt waiting for further commands such as Q, which you can use to exit the manual."
  },
  {
    "objectID": "pre-workshop/software-install.html#additional-resources",
    "href": "pre-workshop/software-install.html#additional-resources",
    "title": "Installation Instructions and Set-Up",
    "section": "Additional Resources",
    "text": "Additional Resources\nhttps://github.com/bcgov/BC-Policy-Framework-For-GitHub"
  },
  {
    "objectID": "CODE_OF_CONDUCT.html",
    "href": "CODE_OF_CONDUCT.html",
    "title": "1 Contributor Code of Conduct",
    "section": "",
    "text": "1 Contributor Code of Conduct\nAs contributors and maintainers of this project, and in the interest of fostering an open and welcoming community, we pledge to respect all people who contribute through reporting issues, posting feature requests, updating documentation, submitting pull requests or patches, and other activities.\nWe are committed to making participation in this project a harassment-free experience for everyone, regardless of level of experience, gender, gender identity and expression, sexual orientation, disability, personal appearance, body size, race, ethnicity, age, religion, or nationality.\nExamples of unacceptable behavior by participants include:\n\nThe use of sexualized language or imagery\nPersonal attacks\nTrolling or insulting/derogatory comments\nPublic or private harassment\nPublishing other’s private information, such as physical or electronic addresses, without explicit permission\nOther unethical or unprofessional conduct\n\nProject maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.\nBy adopting this Code of Conduct, project maintainers commit themselves to fairly and consistently applying these principles to every aspect of managing this project. Project maintainers who do not follow or enforce the Code of Conduct may be permanently removed from the project team.\nThis Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community.\nInstances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting a project maintainer at bonnie.robert@gov.bc.ca or lindsay.forestall@gov.bc.ca. All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. Maintainers are obligated to maintain confidentiality with regard to the reporter of an incident.\nThis Code of Conduct is adapted from the Contributor Covenant, version 1.3.0, available at http://contributor-covenant.org/version/1/3/0/\n\nThis project was created using the bcgovr package."
  },
  {
    "objectID": "course-outline.html",
    "href": "course-outline.html",
    "title": "Course Outline",
    "section": "",
    "text": "Pre-Workshop Installation and Set Up\nLearning Objective: Set up a GitHub account and install git (pre-workshop).\nInstructions: Installation and Set-Up\nAssignment: Pre-Workshop Assignment\n\nTopics/Learning Outcomes:\n\nDownload Git for Windows and bundled software (includes Git Bash) (PC only)\nDownload Git for Mac installer (Mac only)\nCreate a GitHub account with m2FA, PAT for https connection\nConfigure git\nPre-workshop assignment to show local configuration and connection to GitHub\n\nCourse Reference Material:\n\nSW Carpentry Episode 2. Setting Up Git\nbcgov-r-geo-workshop Lesson 1\n\n\n\nSection 1. Introductions and What is Version Control?\nLearning Objective: Understand the value-add of using version control and the the basics of how automated version control systems work.\nTopics:\n\nHow version control systems work\nWhat is a repository?\nWhat is the value-add of using version control in teams? individually?\n\nCourse Reference Material:\n\nSW Carpentry Episode 1. Automated Version Control\n\n\n\nSection 2. Working Locally with Git\nLearning Objective: Use command-line git to track local file changes.\nTopics:\n\nDefault branch naming (inclusive language)\nWhat is Bash\nBash-specific commands: mkdir, rm -r, cd, ls\nGit Bash commands: init, commit, add, status, log\nDirectory structure\nTracking changes made to a text doc\nWhat to do when when -m is omitted.\n\nCourse Reference Material:\n\nSW Carpentry Episode 3. Creating a Repository (Local)\nSW Carpentry Episode 4. Tracking Changes\nbcgov-r-geo-workshop Lesson 2\nbcgov-r-geo-workshop Lesson 3\nbcgov-r-geo-workshop Lesson 5\n\n\n\nSection 3. Remote Code Hosting and GitHub\nLearning Objective: What are remote hosting platforms and why do we use them?\nTopics:\n\nMore on secure authentication/login: username/password/2FA to sign in to account, PAT to authenticate\nGit Bash commands: push, pull\nCreate a remote repository\nClone a remote repostitory\nPush local changes to GitHub.\n.gitgnore and subdirectories (we don’t want ppl pushing data to GitHub)\n.gitkeep (time permitting)\n\nCourse Reference Material:\n\nSW Carpentry Episode 6. Ignoring Things\nSW Carpentry Episode 7. Remotes in GitHub\nbcgov-r-geo-workshop Lesson 6\nGithub: Keeping your Account and Data Secure\n\n\n\nSection 4. BCGov GitHub Organization\nLearning Objective: Understand how the bcgov framework, policy and related tools help B.C. government employees share code on GitHub\nTopics:\n\nwhat is the bcgov organization framework\nbcgov policy framework and licensing\n\nCourse Reference Material:\n\nSW Carpentry Episode 10. Open Science\nSW Carpentry Episode 11. Licensing\nSW Carpentry Episode 12. Citation\nSW Carpentry Episode 13. Hosting\n\nFurther Links to bcgov Organization Resources:\n\nContent Approval Checklist\nBC Gov Organizations in GitHub\nPolicy Framework",
    "crumbs": [
      "About",
      "Course Outline"
    ]
  },
  {
    "objectID": "pre-workshop/assignment.html",
    "href": "pre-workshop/assignment.html",
    "title": "Pre-Workshop Assignment",
    "section": "",
    "text": "To maximize our time together on the day of the workshop, we ask that you come prepared with the necessary software installed and correctly configured on your local machine. First, ensure you have thoroughly reviewed and completed the steps outlined in the Installation Instructions and Set-Up Guide, which can be found under Pre-Workshop Materials in the top menu bar.\nNext, compile the following information into a single Word or PDF document and submit it to the course facilitator(s) via email."
  },
  {
    "objectID": "pre-workshop/assignment.html#a-screen-shot-of-your-git-configurations",
    "href": "pre-workshop/assignment.html#a-screen-shot-of-your-git-configurations",
    "title": "Pre-Workshop Assignment",
    "section": "1 A screen shot of your git configurations",
    "text": "1 A screen shot of your git configurations\nOpen the application Git Bash on your local computer and enter the following commands at the command prompt.\n$ git config -–list\nCapture a screen shot of the command-line output."
  },
  {
    "objectID": "pre-workshop/assignment.html#a-screen-shot-of-your-github-handle.",
    "href": "pre-workshop/assignment.html#a-screen-shot-of-your-github-handle.",
    "title": "Pre-Workshop Assignment",
    "section": "2 A screen shot of your GitHub handle.",
    "text": "2 A screen shot of your GitHub handle.\nSign in to GitHub and left-click on your avatar in the top right corner.\n\n\n\nYour GitHub Avatar\n\n\nYour GitHub handle is in bold font above your account name.\n\n\n\nYour GitHub Handle\n\n\nGenerally, your GitHub handle will be similar to your account name (FirstnameLastname), but this is not strictly required."
  },
  {
    "objectID": "materials/03-remote-hosting.html",
    "href": "materials/03-remote-hosting.html",
    "title": "3. Remote Code Hosting and GitHub",
    "section": "",
    "text": "Collaboration\n\n\nVersion control really comes into its own when we begin to collaborate with other people. We already have most of the machinery we need to do this; the only thing missing is to copy changes from one repository to another.\nSystems like Git allow us to move work between two or more repositories. The repositories can live on separate computers or network locations. In practice, we often use one copy as a central hub, and keep it on the web rather than on someone’s laptop. This is your source of truth repository. Anything that lives here is what is then shared between collaborators. Each individual collaborating on the project will have a local version of this shared repository on their own computer. This is where you make changes, edits, and updates that you would eventually like to add to the rest of your shared work. Most programmers use a hosting service like GitHub to hold the central repositories; and this is true for many BC Government employees.\nIf you recall, in the pre-workshop, you created a GitHub account and associated it with your GitHub handle (or ID). You also configured your computer with a token (PAT) in a way that should seamlessly allow us to to create a remote repository on GitHub that will be linked to our local repository. Then we will share the changes we’ve made to our current project with the world.\n\n\n\nLog in to GitHub. Your personal dashboard is the first page you’ll see when you sign in on GitHub.\nTip: To access your personal dashboard once you’re signed in, click the invertocat  logo in the upper-left corner of any page on GitHub.\nClick on the + icon in the top right corner of your personal dashboard, then New Repository\nName your repository “planets”. Further down the page are other options available to us that can be toggled to suit the repository’s purpose. For this workshop it’s fine to create a “Public” repository. However, as this repository will be connected to a local repository, it needs to be empty. Therefore, leave “Add a README file” unchecked, and select “None” as options for both “Add .gitignore” and “Add a license.”\n\n\n\n\n\n\n\nCreating Empty Repositories\n\n\n\nMore often than not, you will want to include a README, a .gitignore, and a license. We will talk more about these pieces in Part 4: bcgov GitHub Organization. However, because we are connecting to a locally created git repository that already contains documents, we need to provide a blank repository to connect with.\nFor most projects, I strongly recommend starting with a remote repository first (with a README, .gitignore and license automatically included), and then cloning this remote repository into a local location. We will go over cloning a repository in Section 3.5: Pulling changes from GitHub!\n\n\n\nClick “Create Repository”. As soon as the repository is created, GitHub displays a page with a URL and some information on how to configure your local repository.\n\n\n\nMake sure HTTPS is selected and then click the clipboard icon to copy the URL. We will use this URL in the next section.\n\nYou have effectively done the following on GitHub’s servers:\n\n$ mkdir planets\n$ cd planets\n$ git init\n\n\n\n\n\n\n\nHTTPS vs SSH - what’s the difference?\n\n\n\nHTTP and SSH refer to different protocols Git can use to transfer data. SSH is ubiquitous; many network admins have experience with them and many OS distributions are set up with them or have tools to manage them. Access over SSH is secure as all data transfer is encrypted and authenticated. It is also efficient, making the data as compact as possible before transferring it.\nHTTP operates very similarly to the SSH protocol but runs over standard HTTPS ports and can use various HTTP authentication mechanisms, meaning it’s often easier on the user than something like SSH, since you can use things like username/password authentication rather than having to set up SSH keys.\n\n\nIf you remember back to the earlier episode where we added and committed our earlier work on mars.txt, we had a diagram of the local repository which looked like this:\n\nNow that we have two repositories, we need a diagram like this\n\n\n\n\n\n\n\nNote\n\n\n\nOur local repository still contains our earlier work on mars.txt, but the remote repository on GitHub appears empty as it doesn’t contain any files yet.\n\n\n\n\n\nNow we connect the two repositories. We do this by making the GitHub repository a remote for the local repository. Remote branches are configured using the git remote command.\nGo into the local planets repository, and run this command (using the URL copied to our clipboard):\n\n$ git remote add origin &lt;paste copied URL here&gt;\n\nalternatively,\n\n$ git remote add origin https://github.com/&lt;yourusername&gt;/planets.git\n\n\n\n\n\n\n\nNote\n\n\n\n“origin” is a local name used to refer to the remote repository. It could be called anything, but “origin” is a convention that is often used by default in git and GitHub, so it’s helpful to stick with this unless there’s a reason not to.\n\n\nWe can check that the command has worked by running git remote -v:\n\n$ git remote -v\n\norigin   https://github.com/&lt;yourusername&gt;/planets.git (fetch)\norigin   https://github.com/&lt;youusername&gt;/planets.git (push)\n\n\n\nNow that authentication is setup, we can return to the remote. The git push command is used to upload local repository content to a remote repository. This command is how you transfer commits from your local repository to the repository on GitHub.\n\n$ git push -u origin main\n\nEnumerating objects: 16, done.\nCounting objects: 100% (16/16), done.\nDelta compression using up to 8 threads.\nCompressing objects: 100% (11/11), done.\nWriting objects: 100% (16/16), 1.45 KiB | 372.00 KiB/s, done.\nTotal 16 (delta 2), reused 0 (delta 0)\nremote: Resolving deltas: 100% (2/2), done.\nTo https://github.com/&lt;youusername&gt;/planets.git\n * [new branch]      main -&gt; main\nThe git push command takes three arguments: the name of the remote repository (origin), the branch name (main) that you wish to push changes from, and -u to specify that the local main branch should track the remote main branch. Used without the branch name (git push origin) will push changes from all local branches to the remote. We may also use git push without specifying any arguments if we’ve already configured the remote for the current branch with the -u optoin. Git push will push only changes on our current branch to the remote.\n\n\n\n\n\n\npush vs push origin vs push origin main vs push -u origin main??\n\n\n\nIt can get confusing trying to keep track of whether or not extra options are needed when pushing changes to the remote repository. As a good rule of thumb:\n\nOn the first push from a branch to the remote (origin), use the full call: git push -u origin main so that the remote repository knows that the main branch from your local machine should track the main branch from the remote GitHub repository.\n\nThis is called setting your remote repository to be the upstream repository.\nIt is the source of truth, and all changes should flow downstream from the remote GitHub repository to every local repository.\n\nFor every push from the same branch after this, git push will be sufficient.\n\n\n\nNow our repositories look like:\n\n\n\n\nGit allows you to work collaboratively, with multiple people making changes to the same repo and sharing those changes through GitHub. We’ve seen how to create a repository and push changes to it; now we will see how to pull another person’s changes from Github.\nStart by opening a second terminal window. This window will represent your colleague, working on another computer. In the second window, navigate to the folder one level “up” in the directory tree from where you have your planets repository.\n$ cd c:/users/bashcrof\n$ ls\nplanets\nYou don’t want to overwrite your first version of planets.git, so you will clone the planets repository to a different location.\n\n$ mkdir collab\n$ cd collab\n\nClone the planets repo substituting in your GitHub user name. You can also find the URL from GitHub. Open the remote repository on GitHub, click on the &lt;&gt; Code button, and then copy the URL from there.\n\n\n\nCloning the repository from GitHub.\n\n\ngit clone https://github.com/&lt;your-GitHub-username&gt;/planets.git\nCloning into 'planets'...\nremote: Enumerating objects: 10, done.\nremote: Counting objects: 100% (10/10), done.\nremote: Compressing objects: 100% (5/5), done.\nremote: Total 10 (delta 2), reused 10 (delta 2), pack-reused 0\nReceiving objects: 100% (10/10), done.\nResolving deltas: 100% (2/2), done.\n\n\n\n\n\n\nRemote Add Origin vs. Clone\n\n\n\nNote that when we clone a remote GitHub repository instead of connecting a blank repository to a local repository, we didn’t have to create a remote called origin: Git uses this name by default when we clone a repository into a new local location. (This is why origin was a sensible choice earlier when we were setting up remotes by hand.)\nYou can check that the remote ‘origin’ repository has been properly set up using the git remote -v command again.\n\n\n\n\n\n\n\n\nGiving Collaborators Access\n\n\n\n\n\nIn this scenario, you won’t need to give anyone access on GitHub, because GitHub will recognize both contributors as you.\nHowever, typically you will need to allow access to other members of GitHub - otherwise anyone could go in and update your files at any point!\nTo give collaborator access, navigate to the repository page on GitHub, and click the “Settings” button on the right of the banner. Then, click “Add people” and then enter the username of the person you wish to collaborate with.\n\n\n\nAdding a collaborator on GitHub.\n\n\n\n\n\nYou should now have a new planets folder in the collab directory. Switch to this planets folder using the cd command. You can now make a change in your clone of the original repository, exactly the same way as we’ve been doing before. Add a line of text to a .txt file (using your favourite text editing software) and save it to your cloned repository.\n\n$ cat pluto.txt\n\nIt is so a planet!\nOnce we are happy with the changes we have made to the project, we can commit each change locally.\n\n$ git add pluto.txt\n$ git commit -m \"Add notes about Pluto\"\n\n 1 file changed, 1 insertion(+)\n create mode 100644 pluto.txt\nAt this point, stop and compare the three repositories.\n\n\nOriginal Repository\n├── planets\n|   ├── mars.txt\n|   ├── .git\n\nGitHub Repository\n├── planets\n|   ├── mars.txt\n|   ├── .git\n\nCloned Repository\n├── planets\n|   ├── mars.txt\n|   ├── pluto.txt ***\n|   ├── .git\n\n\nNotice how we only have the new pluto.txt file in the cloned repository. At this point, we have not yet told any of the other locations about the changes we have made. To communicate the changes and add them to our shared, source of truth, remote repository, we once again do a git push command. Note that because we cloned this repository from an already existing source, Git will already know that this main branch is set up to track the remote main branch, and so we do not need any further arguments:\n\n$ git push\n\nEnumerating objects: 4, done.\nCounting objects: 100% (4/4), done.\nDelta compression using up to 12 threads\nCompressing objects: 100% (2/2), done.\nWriting objects: 100% (3/3), 302 bytes | 302.00 KiB/s, done.\nTotal 3 (delta 0), reused 0 (delta 0), pack-reused 0\nTo https://github.com/&lt;yourusername&gt;/planets.git\n   3abcea2..b792d59  main -&gt; main\nNow our three work locations will look something like this:\n\n\nOriginal Repository\n├── planets\n|   ├── mars.txt\n|   ├── .git\n\nGitHub Repository\n├── planets\n|   ├── mars.txt\n|   ├── pluto.txt ***\n|   ├── .git\n\nCloned Repository\n├── planets\n|   ├── mars.txt\n|   ├── pluto.txt ***\n|   ├── .git\n\n\nWe have told (pushed) the remote repository that we have made changes, and sent them to the remote repo. However, the original repository is still unaware of the changes that have been made.\nTo download your changes from GitHub, switch back to the bash window (where you were working in your original repository) and enter:\n\n$ git pull origin main\n\nFrom https://github.com/&lt;yourusername&gt;/planets\n * branch            main       -&gt; FETCH_HEAD\nUpdating 3abcea2..b792d59\nFast-forward\n pluto.txt | 1 +\n 1 file changed, 1 insertion(+)\n create mode 100644 pluto.txt\nThe git pull command also takes two arguments: the name of the remote repository (origin) and the remote branch name (main). The full command will pull any new changes present on the main branch of the remote repository into the local main branch (and then further merge these changes into your current branch). We may also use git pull without specifying any arguments if we’ve already configured the upstream remote for the current branch.\n\n\n\n\n\n\npull vs pull origin main??\n\n\n\nJust like with pushes, it can be confusing to remember if we need further arguments when pulling from the remote repository. As a good rule of thumb:\n\nIf we have cloned the repository, OR made sure that the remote branch is set up to be upstream from our own via a previous push, git pull will suffice.\n\nThis will pull any remote changes on the branch you are currently using into your local copy of the same branch.\nNote that this will not work if we have not yet set up a local branch to track an upstream remote branch.\n\nIf we explicitly want to merge the main branch of the remote repository into some other local branch of work, git pull origin main will be required.\n\nAgain, working off of multiple branches is a more complex method of work that we will not get into here. If you would like to learn more about branching in git, you can read the official documentation here.\n\n\n\n\nAfter pulling all the changes from the remote repository back to the original, our three repositories should now look like this:\n\n\nOriginal Repository\n├── planets\n|   ├── mars.txt\n|   ├── pluto.txt ***\n|   ├── .git\n\nGitHub Repository\n├── planets\n|   ├── mars.txt\n|   ├── pluto.txt ***\n|   ├── .git\n\nCloned Repository\n├── planets\n|   ├── mars.txt\n|   ├── pluto.txt ***\n|   ├── .git\n\n\nNow the three repositories (original local, second local, and the one on GitHub) are back in sync!\n\n\n\nTo this point, we have learned a lot of different git commands and workflows involved in tracking all of our changes, keeping our repositories up-to-date, and collaborating across computers using GitHub. While there are multiple levels of nuance that go into each of these steps, let’s lay out a typical workflow.\n\n\n\n\n\n\nTip\n\n\n\nThe table below doubles as a handy cheatsheet; take a screenshot and save for future reference!\n\n\n\n\n\n\n\n\n\n\nOrder\nAction\nGit Command\n\n\n\n\n1 (Once Only)\nCreate remote\n(Done on GitHub)\n\n\n2 (Once Only)\nClone remote\ngit clone https://github.com/path/to/remote\n\n\n3\nUpdate local\ngit pull origin main\n\n\n4\nMake changes\n(Done in editor)\n\n\n5\nStage changes\ngit add numbers.txt\n\n\n6\nCommit changes\ngit commit -m \"Add 100 to numbers.txt\"\n\n\n7\nUpdate remote\ngit push origin main\n\n\n\n\n\n\nWhat if we have files that we do not want Git to track for us, like backup files created by our editor or intermediate files created during data analysis? This often is the case in BC Government data projects.\nLet’s create a file called a.csv that contains some data about the Red Planet’s average temperature. Open a new csv using Excel and add two columns named ‘Time’ and ‘Temperature’. Add a few rows of data if you want and save it to the planets directory. Then check the output of git status.\n$ git status\nOn branch main\nUntracked files:\n  (use \"git add &lt;file&gt;...\" to include in what will be committed)\n\n    a.csv\n\nnothing added to commit but untracked files present (use \"git add\" to track)\nPutting data files under version control can be a waste of disk space and may put privacy at risk. As many BC Stats projects involve data with PI or other sensitive information, we generally follow a best practice of not pushing data to GitHub. We accomplish this by creating a file in the root directory of our project called a .gitignore.\n.gitignore files are plain text files; you can open the file with your chosen text editor. Open up your favorite text editor and type the following line into the first line of the file:\n*.csv\nThen save and close the file, naming it .gitignore. Don’t forget the dot at the beginning!\n\n\n\n\n\n\nNo .txt!\n\n\n\nAlthough a .gitignore is a plain text file, it doesn’t carry the “.txt” extension. To be sure you aren’t saving a .gitignore.txt file, check the “Hidden Items” check box under Show/hide in your File Explorer Window.\n\n\nThese patterns tell Git to ignore any file whose name ends in .csv. If any of these files were already being tracked, Git would continue to track them. So be sure to create your .gitignore early in the process!\nOnce we have created this file, the output of git status is much cleaner:\n$ git status\nOn branch main\nUntracked files:\n  (use \"git add &lt;file&gt;...\" to include in what will be committed)\n\n    .gitignore\n\nnothing added to commit but untracked files present (use \"git add\" to track)\n\nOn Unix-based operating system these files are called hidden files but on a PC they are not hidden. As Git Bash provides a Unix-like environments, to see your .gitignore in Git Bash, type “ls -a”.\n\nAnd since everyone we are sharing our repository with will probably want to ignore the same things that we are ignoring, let’s add and commit our .gitignore:\n\n$ git add .gitignore\n$ git commit -m \"Ignore data file\"\n\nNow if we try to add our csv files, .gitignore helps us avoid accidentally adding files to the repository that we don’t want to track. It also gives us a way to override the .gitignore with the -f flag.\n\n$ git add a.csv\n\nThe following paths are ignored by one of your .gitignore files:\na.csv\nUse -f if you really want to add them.\nGo ahead and push your .gitignore to the remote so other people working on our project can use it too.\n\n$ git push\n\nWe can also ignore full subfolders by adding the folder name to our .gitignore.\nAdd another line to your .gitignore so it looks like:\n*.csv\nresults/\nMake a subfolder in planets:\n\n$ mkdir results\n\nAnd then add a .txt file to that subfolder. Again, open up your favorite text editor and add some text to a file and save your changes. Switch back to command line when you’re finished and check the git status.\n\n$ git status\n\ngit status\nOn branch main\nUntracked files:\n  (use \"git add &lt;file&gt;...\" to include in what will be committed)\n        .gitignore\n\nnothing added to commit but untracked files present (use \"git add\" to track)\nThe subfolder “results” and it’s contents are ignored. This is handy for keeping all of your data in a single folder. You simply add the data folder to your .gitignore and the contents will not be accidentally pushed.",
    "crumbs": [
      "About",
      "Course Sections",
      "3. Remote Code Hosting and GitHub"
    ]
  },
  {
    "objectID": "materials/03-remote-hosting.html#creating-a-remote-repository",
    "href": "materials/03-remote-hosting.html#creating-a-remote-repository",
    "title": "3. Remote Code Hosting and GitHub",
    "section": "",
    "text": "Log in to GitHub. Your personal dashboard is the first page you’ll see when you sign in on GitHub.\nTip: To access your personal dashboard once you’re signed in, click the invertocat  logo in the upper-left corner of any page on GitHub.\nClick on the + icon in the top right corner of your personal dashboard, then New Repository\nName your repository “planets”. Further down the page are other options available to us that can be toggled to suit the repository’s purpose. For this workshop it’s fine to create a “Public” repository. However, as this repository will be connected to a local repository, it needs to be empty. Therefore, leave “Add a README file” unchecked, and select “None” as options for both “Add .gitignore” and “Add a license.”\n\n\n\n\n\n\n\nCreating Empty Repositories\n\n\n\nMore often than not, you will want to include a README, a .gitignore, and a license. We will talk more about these pieces in Part 4: bcgov GitHub Organization. However, because we are connecting to a locally created git repository that already contains documents, we need to provide a blank repository to connect with.\nFor most projects, I strongly recommend starting with a remote repository first (with a README, .gitignore and license automatically included), and then cloning this remote repository into a local location. We will go over cloning a repository in Section 3.5: Pulling changes from GitHub!\n\n\n\nClick “Create Repository”. As soon as the repository is created, GitHub displays a page with a URL and some information on how to configure your local repository.\n\n\n\nMake sure HTTPS is selected and then click the clipboard icon to copy the URL. We will use this URL in the next section.\n\nYou have effectively done the following on GitHub’s servers:\n\n$ mkdir planets\n$ cd planets\n$ git init\n\n\n\n\n\n\n\nHTTPS vs SSH - what’s the difference?\n\n\n\nHTTP and SSH refer to different protocols Git can use to transfer data. SSH is ubiquitous; many network admins have experience with them and many OS distributions are set up with them or have tools to manage them. Access over SSH is secure as all data transfer is encrypted and authenticated. It is also efficient, making the data as compact as possible before transferring it.\nHTTP operates very similarly to the SSH protocol but runs over standard HTTPS ports and can use various HTTP authentication mechanisms, meaning it’s often easier on the user than something like SSH, since you can use things like username/password authentication rather than having to set up SSH keys.\n\n\nIf you remember back to the earlier episode where we added and committed our earlier work on mars.txt, we had a diagram of the local repository which looked like this:\n\nNow that we have two repositories, we need a diagram like this\n\n\n\n\n\n\n\nNote\n\n\n\nOur local repository still contains our earlier work on mars.txt, but the remote repository on GitHub appears empty as it doesn’t contain any files yet.",
    "crumbs": [
      "About",
      "Course Sections",
      "3. Remote Code Hosting and GitHub"
    ]
  },
  {
    "objectID": "materials/03-remote-hosting.html#connecting-to-a-remote-repository",
    "href": "materials/03-remote-hosting.html#connecting-to-a-remote-repository",
    "title": "3. Remote Code Hosting and GitHub",
    "section": "",
    "text": "Now we connect the two repositories. We do this by making the GitHub repository a remote for the local repository. Remote branches are configured using the git remote command.\nGo into the local planets repository, and run this command (using the URL copied to our clipboard):\n\n$ git remote add origin &lt;paste copied URL here&gt;\n\nalternatively,\n\n$ git remote add origin https://github.com/&lt;yourusername&gt;/planets.git\n\n\n\n\n\n\n\nNote\n\n\n\n“origin” is a local name used to refer to the remote repository. It could be called anything, but “origin” is a convention that is often used by default in git and GitHub, so it’s helpful to stick with this unless there’s a reason not to.\n\n\nWe can check that the command has worked by running git remote -v:\n\n$ git remote -v\n\norigin   https://github.com/&lt;yourusername&gt;/planets.git (fetch)\norigin   https://github.com/&lt;youusername&gt;/planets.git (push)",
    "crumbs": [
      "About",
      "Course Sections",
      "3. Remote Code Hosting and GitHub"
    ]
  },
  {
    "objectID": "materials/03-remote-hosting.html#push-local-changes-to-a-remote-repository",
    "href": "materials/03-remote-hosting.html#push-local-changes-to-a-remote-repository",
    "title": "3. Remote Code Hosting and GitHub",
    "section": "",
    "text": "Now that authentication is setup, we can return to the remote. The git push command is used to upload local repository content to a remote repository. This command is how you transfer commits from your local repository to the repository on GitHub.\n\n$ git push -u origin main\n\nEnumerating objects: 16, done.\nCounting objects: 100% (16/16), done.\nDelta compression using up to 8 threads.\nCompressing objects: 100% (11/11), done.\nWriting objects: 100% (16/16), 1.45 KiB | 372.00 KiB/s, done.\nTotal 16 (delta 2), reused 0 (delta 0)\nremote: Resolving deltas: 100% (2/2), done.\nTo https://github.com/&lt;youusername&gt;/planets.git\n * [new branch]      main -&gt; main\nThe git push command takes three arguments: the name of the remote repository (origin), the branch name (main) that you wish to push changes from, and -u to specify that the local main branch should track the remote main branch. Used without the branch name (git push origin) will push changes from all local branches to the remote. We may also use git push without specifying any arguments if we’ve already configured the remote for the current branch with the -u optoin. Git push will push only changes on our current branch to the remote.\n\n\n\n\n\n\npush vs push origin vs push origin main vs push -u origin main??\n\n\n\nIt can get confusing trying to keep track of whether or not extra options are needed when pushing changes to the remote repository. As a good rule of thumb:\n\nOn the first push from a branch to the remote (origin), use the full call: git push -u origin main so that the remote repository knows that the main branch from your local machine should track the main branch from the remote GitHub repository.\n\nThis is called setting your remote repository to be the upstream repository.\nIt is the source of truth, and all changes should flow downstream from the remote GitHub repository to every local repository.\n\nFor every push from the same branch after this, git push will be sufficient.\n\n\n\nNow our repositories look like:",
    "crumbs": [
      "About",
      "Course Sections",
      "3. Remote Code Hosting and GitHub"
    ]
  },
  {
    "objectID": "materials/03-remote-hosting.html#pulling-changes-from-github",
    "href": "materials/03-remote-hosting.html#pulling-changes-from-github",
    "title": "3. Remote Code Hosting and GitHub",
    "section": "",
    "text": "Git allows you to work collaboratively, with multiple people making changes to the same repo and sharing those changes through GitHub. We’ve seen how to create a repository and push changes to it; now we will see how to pull another person’s changes from Github.\nStart by opening a second terminal window. This window will represent your colleague, working on another computer. In the second window, navigate to the folder one level “up” in the directory tree from where you have your planets repository.\n$ cd c:/users/bashcrof\n$ ls\nplanets\nYou don’t want to overwrite your first version of planets.git, so you will clone the planets repository to a different location.\n\n$ mkdir collab\n$ cd collab\n\nClone the planets repo substituting in your GitHub user name. You can also find the URL from GitHub. Open the remote repository on GitHub, click on the &lt;&gt; Code button, and then copy the URL from there.\n\n\n\nCloning the repository from GitHub.\n\n\ngit clone https://github.com/&lt;your-GitHub-username&gt;/planets.git\nCloning into 'planets'...\nremote: Enumerating objects: 10, done.\nremote: Counting objects: 100% (10/10), done.\nremote: Compressing objects: 100% (5/5), done.\nremote: Total 10 (delta 2), reused 10 (delta 2), pack-reused 0\nReceiving objects: 100% (10/10), done.\nResolving deltas: 100% (2/2), done.\n\n\n\n\n\n\nRemote Add Origin vs. Clone\n\n\n\nNote that when we clone a remote GitHub repository instead of connecting a blank repository to a local repository, we didn’t have to create a remote called origin: Git uses this name by default when we clone a repository into a new local location. (This is why origin was a sensible choice earlier when we were setting up remotes by hand.)\nYou can check that the remote ‘origin’ repository has been properly set up using the git remote -v command again.\n\n\n\n\n\n\n\n\nGiving Collaborators Access\n\n\n\n\n\nIn this scenario, you won’t need to give anyone access on GitHub, because GitHub will recognize both contributors as you.\nHowever, typically you will need to allow access to other members of GitHub - otherwise anyone could go in and update your files at any point!\nTo give collaborator access, navigate to the repository page on GitHub, and click the “Settings” button on the right of the banner. Then, click “Add people” and then enter the username of the person you wish to collaborate with.\n\n\n\nAdding a collaborator on GitHub.\n\n\n\n\n\nYou should now have a new planets folder in the collab directory. Switch to this planets folder using the cd command. You can now make a change in your clone of the original repository, exactly the same way as we’ve been doing before. Add a line of text to a .txt file (using your favourite text editing software) and save it to your cloned repository.\n\n$ cat pluto.txt\n\nIt is so a planet!\nOnce we are happy with the changes we have made to the project, we can commit each change locally.\n\n$ git add pluto.txt\n$ git commit -m \"Add notes about Pluto\"\n\n 1 file changed, 1 insertion(+)\n create mode 100644 pluto.txt\nAt this point, stop and compare the three repositories.\n\n\nOriginal Repository\n├── planets\n|   ├── mars.txt\n|   ├── .git\n\nGitHub Repository\n├── planets\n|   ├── mars.txt\n|   ├── .git\n\nCloned Repository\n├── planets\n|   ├── mars.txt\n|   ├── pluto.txt ***\n|   ├── .git\n\n\nNotice how we only have the new pluto.txt file in the cloned repository. At this point, we have not yet told any of the other locations about the changes we have made. To communicate the changes and add them to our shared, source of truth, remote repository, we once again do a git push command. Note that because we cloned this repository from an already existing source, Git will already know that this main branch is set up to track the remote main branch, and so we do not need any further arguments:\n\n$ git push\n\nEnumerating objects: 4, done.\nCounting objects: 100% (4/4), done.\nDelta compression using up to 12 threads\nCompressing objects: 100% (2/2), done.\nWriting objects: 100% (3/3), 302 bytes | 302.00 KiB/s, done.\nTotal 3 (delta 0), reused 0 (delta 0), pack-reused 0\nTo https://github.com/&lt;yourusername&gt;/planets.git\n   3abcea2..b792d59  main -&gt; main\nNow our three work locations will look something like this:\n\n\nOriginal Repository\n├── planets\n|   ├── mars.txt\n|   ├── .git\n\nGitHub Repository\n├── planets\n|   ├── mars.txt\n|   ├── pluto.txt ***\n|   ├── .git\n\nCloned Repository\n├── planets\n|   ├── mars.txt\n|   ├── pluto.txt ***\n|   ├── .git\n\n\nWe have told (pushed) the remote repository that we have made changes, and sent them to the remote repo. However, the original repository is still unaware of the changes that have been made.\nTo download your changes from GitHub, switch back to the bash window (where you were working in your original repository) and enter:\n\n$ git pull origin main\n\nFrom https://github.com/&lt;yourusername&gt;/planets\n * branch            main       -&gt; FETCH_HEAD\nUpdating 3abcea2..b792d59\nFast-forward\n pluto.txt | 1 +\n 1 file changed, 1 insertion(+)\n create mode 100644 pluto.txt\nThe git pull command also takes two arguments: the name of the remote repository (origin) and the remote branch name (main). The full command will pull any new changes present on the main branch of the remote repository into the local main branch (and then further merge these changes into your current branch). We may also use git pull without specifying any arguments if we’ve already configured the upstream remote for the current branch.\n\n\n\n\n\n\npull vs pull origin main??\n\n\n\nJust like with pushes, it can be confusing to remember if we need further arguments when pulling from the remote repository. As a good rule of thumb:\n\nIf we have cloned the repository, OR made sure that the remote branch is set up to be upstream from our own via a previous push, git pull will suffice.\n\nThis will pull any remote changes on the branch you are currently using into your local copy of the same branch.\nNote that this will not work if we have not yet set up a local branch to track an upstream remote branch.\n\nIf we explicitly want to merge the main branch of the remote repository into some other local branch of work, git pull origin main will be required.\n\nAgain, working off of multiple branches is a more complex method of work that we will not get into here. If you would like to learn more about branching in git, you can read the official documentation here.\n\n\n\n\nAfter pulling all the changes from the remote repository back to the original, our three repositories should now look like this:\n\n\nOriginal Repository\n├── planets\n|   ├── mars.txt\n|   ├── pluto.txt ***\n|   ├── .git\n\nGitHub Repository\n├── planets\n|   ├── mars.txt\n|   ├── pluto.txt ***\n|   ├── .git\n\nCloned Repository\n├── planets\n|   ├── mars.txt\n|   ├── pluto.txt ***\n|   ├── .git\n\n\nNow the three repositories (original local, second local, and the one on GitHub) are back in sync!",
    "crumbs": [
      "About",
      "Course Sections",
      "3. Remote Code Hosting and GitHub"
    ]
  },
  {
    "objectID": "materials/03-remote-hosting.html#a-typical-workflow",
    "href": "materials/03-remote-hosting.html#a-typical-workflow",
    "title": "3. Remote Code Hosting and GitHub",
    "section": "",
    "text": "To this point, we have learned a lot of different git commands and workflows involved in tracking all of our changes, keeping our repositories up-to-date, and collaborating across computers using GitHub. While there are multiple levels of nuance that go into each of these steps, let’s lay out a typical workflow.\n\n\n\n\n\n\nTip\n\n\n\nThe table below doubles as a handy cheatsheet; take a screenshot and save for future reference!\n\n\n\n\n\n\n\n\n\n\nOrder\nAction\nGit Command\n\n\n\n\n1 (Once Only)\nCreate remote\n(Done on GitHub)\n\n\n2 (Once Only)\nClone remote\ngit clone https://github.com/path/to/remote\n\n\n3\nUpdate local\ngit pull origin main\n\n\n4\nMake changes\n(Done in editor)\n\n\n5\nStage changes\ngit add numbers.txt\n\n\n6\nCommit changes\ngit commit -m \"Add 100 to numbers.txt\"\n\n\n7\nUpdate remote\ngit push origin main",
    "crumbs": [
      "About",
      "Course Sections",
      "3. Remote Code Hosting and GitHub"
    ]
  },
  {
    "objectID": "materials/03-remote-hosting.html#ignoring-things",
    "href": "materials/03-remote-hosting.html#ignoring-things",
    "title": "3. Remote Code Hosting and GitHub",
    "section": "",
    "text": "What if we have files that we do not want Git to track for us, like backup files created by our editor or intermediate files created during data analysis? This often is the case in BC Government data projects.\nLet’s create a file called a.csv that contains some data about the Red Planet’s average temperature. Open a new csv using Excel and add two columns named ‘Time’ and ‘Temperature’. Add a few rows of data if you want and save it to the planets directory. Then check the output of git status.\n$ git status\nOn branch main\nUntracked files:\n  (use \"git add &lt;file&gt;...\" to include in what will be committed)\n\n    a.csv\n\nnothing added to commit but untracked files present (use \"git add\" to track)\nPutting data files under version control can be a waste of disk space and may put privacy at risk. As many BC Stats projects involve data with PI or other sensitive information, we generally follow a best practice of not pushing data to GitHub. We accomplish this by creating a file in the root directory of our project called a .gitignore.\n.gitignore files are plain text files; you can open the file with your chosen text editor. Open up your favorite text editor and type the following line into the first line of the file:\n*.csv\nThen save and close the file, naming it .gitignore. Don’t forget the dot at the beginning!\n\n\n\n\n\n\nNo .txt!\n\n\n\nAlthough a .gitignore is a plain text file, it doesn’t carry the “.txt” extension. To be sure you aren’t saving a .gitignore.txt file, check the “Hidden Items” check box under Show/hide in your File Explorer Window.\n\n\nThese patterns tell Git to ignore any file whose name ends in .csv. If any of these files were already being tracked, Git would continue to track them. So be sure to create your .gitignore early in the process!\nOnce we have created this file, the output of git status is much cleaner:\n$ git status\nOn branch main\nUntracked files:\n  (use \"git add &lt;file&gt;...\" to include in what will be committed)\n\n    .gitignore\n\nnothing added to commit but untracked files present (use \"git add\" to track)\n\nOn Unix-based operating system these files are called hidden files but on a PC they are not hidden. As Git Bash provides a Unix-like environments, to see your .gitignore in Git Bash, type “ls -a”.\n\nAnd since everyone we are sharing our repository with will probably want to ignore the same things that we are ignoring, let’s add and commit our .gitignore:\n\n$ git add .gitignore\n$ git commit -m \"Ignore data file\"\n\nNow if we try to add our csv files, .gitignore helps us avoid accidentally adding files to the repository that we don’t want to track. It also gives us a way to override the .gitignore with the -f flag.\n\n$ git add a.csv\n\nThe following paths are ignored by one of your .gitignore files:\na.csv\nUse -f if you really want to add them.\nGo ahead and push your .gitignore to the remote so other people working on our project can use it too.\n\n$ git push\n\nWe can also ignore full subfolders by adding the folder name to our .gitignore.\nAdd another line to your .gitignore so it looks like:\n*.csv\nresults/\nMake a subfolder in planets:\n\n$ mkdir results\n\nAnd then add a .txt file to that subfolder. Again, open up your favorite text editor and add some text to a file and save your changes. Switch back to command line when you’re finished and check the git status.\n\n$ git status\n\ngit status\nOn branch main\nUntracked files:\n  (use \"git add &lt;file&gt;...\" to include in what will be committed)\n        .gitignore\n\nnothing added to commit but untracked files present (use \"git add\" to track)\nThe subfolder “results” and it’s contents are ignored. This is handy for keeping all of your data in a single folder. You simply add the data folder to your .gitignore and the contents will not be accidentally pushed.",
    "crumbs": [
      "About",
      "Course Sections",
      "3. Remote Code Hosting and GitHub"
    ]
  },
  {
    "objectID": "materials/04-bcgov-org.html",
    "href": "materials/04-bcgov-org.html",
    "title": "4. BCGov GitHub Organization",
    "section": "",
    "text": "The BCGov GitHub organization on GitHub.com is the only approved venue for Open Source collaboration on Province of British Columbia files. OCIO, together with the BCDevExchange team established this GitHub organization in early 2014 as a method of sharing code and collaborating in the open.\n\n\n\nThe bcgov GitHub Organization\n\n\n\n\n\n\n\n\nBC-Policy-Framework-For-GitHub\n\n\nContributing code to the BCGov organization can be daunting. There are required files, teams to join, codes of conduct to follow, and standards and policies to remain compliant with. Luckily, there is a well documented repository, the BC-Policy-Framework-For-GitHub that contains guidelines for working within the organization. Here we’ll touch on a few of the important points to know about when adding your project code to GitHub.\n\n\nTo contribute to the BCGov organization, a few steps are required:\n\nMake sure you have a GitHub account.\n\nYou must have a bcgov email address associated with the account (you can add a secondary email if needed).\nYou must enable 2-Factor authentication.\n\nBe added to a BCGov repository to collaborate.\nFor those needing to open and manage repositories for BCGov teams, get invited to the organization.\n\nThis can be done by any existing member of the organization, using the Just Ask tool.\n\n\nFor more details on joining the organization, see the joining how-to guide here.\n\n\n\n\n\n\nA bcgov repo\n\n\nIn addition to all your regular project files, every bcgov repository must have three additional files:\n\nLICENSE\n\nThe default for bcgov repositories is to use the Apache 2.0 LICENSE\n\nThe LICENSE file is added directly to the repository (can be selected upon creation)\nBoiler-plate for the Apache 2.0 LICENSE is added to the bottom of your README.md\nBoiler-plate for the Apache 2.0 LICENSE is added to the comments header of every source code file\n\nOther, non-code conduct may require a second license, such as the Creative Commons Attribution 4.0 International.\n\nThis can be added in a footer to your README.md\n\n\nREADME\n\nThe README.md is the landing page for any repository.\nIf a repo has a README, it will be displayed automatically when a repo is opened.\nThis makes it the perfect place to include a brief description of what the project is, what requirements there might be, and any other useful information contributors might need.\n\nCONTRIBUTING\n\n\nThis is a small file that encourages government employees, public, and members of the private sector to contribute to the repository, and gives guidelines on how to do that.\n\nWhile not required, there is also a commonly included file called the CODE-OF-CONDUCT.md. This helps foster an open, kind, inclusive and cooperating environment where people can collaborate.\nSample templates for all required, and the optional code of conduct, can be found in the how-to guide\n\n\n\nThis has only scratched the surface of the information available regarding working in the BCGov GitHub organization. The most useful tool you will find yourself coming back to is the policy framework cheatsheet, which details all of the above and more. This cheatsheet will help to make sure that any new repo you open is compliant with open data policies, and you can hit the ground running with your brand new version control tools!",
    "crumbs": [
      "About",
      "Course Sections",
      "4. BCGov GitHub Organization"
    ]
  },
  {
    "objectID": "materials/04-bcgov-org.html#what-is-it",
    "href": "materials/04-bcgov-org.html#what-is-it",
    "title": "4. BCGov GitHub Organization",
    "section": "",
    "text": "The BCGov GitHub organization on GitHub.com is the only approved venue for Open Source collaboration on Province of British Columbia files. OCIO, together with the BCDevExchange team established this GitHub organization in early 2014 as a method of sharing code and collaborating in the open.\n\n\n\nThe bcgov GitHub Organization",
    "crumbs": [
      "About",
      "Course Sections",
      "4. BCGov GitHub Organization"
    ]
  },
  {
    "objectID": "materials/04-bcgov-org.html#bcgov-policy-framework",
    "href": "materials/04-bcgov-org.html#bcgov-policy-framework",
    "title": "4. BCGov GitHub Organization",
    "section": "",
    "text": "BC-Policy-Framework-For-GitHub\n\n\nContributing code to the BCGov organization can be daunting. There are required files, teams to join, codes of conduct to follow, and standards and policies to remain compliant with. Luckily, there is a well documented repository, the BC-Policy-Framework-For-GitHub that contains guidelines for working within the organization. Here we’ll touch on a few of the important points to know about when adding your project code to GitHub.\n\n\nTo contribute to the BCGov organization, a few steps are required:\n\nMake sure you have a GitHub account.\n\nYou must have a bcgov email address associated with the account (you can add a secondary email if needed).\nYou must enable 2-Factor authentication.\n\nBe added to a BCGov repository to collaborate.\nFor those needing to open and manage repositories for BCGov teams, get invited to the organization.\n\nThis can be done by any existing member of the organization, using the Just Ask tool.\n\n\nFor more details on joining the organization, see the joining how-to guide here.\n\n\n\n\n\n\nA bcgov repo\n\n\nIn addition to all your regular project files, every bcgov repository must have three additional files:\n\nLICENSE\n\nThe default for bcgov repositories is to use the Apache 2.0 LICENSE\n\nThe LICENSE file is added directly to the repository (can be selected upon creation)\nBoiler-plate for the Apache 2.0 LICENSE is added to the bottom of your README.md\nBoiler-plate for the Apache 2.0 LICENSE is added to the comments header of every source code file\n\nOther, non-code conduct may require a second license, such as the Creative Commons Attribution 4.0 International.\n\nThis can be added in a footer to your README.md\n\n\nREADME\n\nThe README.md is the landing page for any repository.\nIf a repo has a README, it will be displayed automatically when a repo is opened.\nThis makes it the perfect place to include a brief description of what the project is, what requirements there might be, and any other useful information contributors might need.\n\nCONTRIBUTING\n\n\nThis is a small file that encourages government employees, public, and members of the private sector to contribute to the repository, and gives guidelines on how to do that.\n\nWhile not required, there is also a commonly included file called the CODE-OF-CONDUCT.md. This helps foster an open, kind, inclusive and cooperating environment where people can collaborate.\nSample templates for all required, and the optional code of conduct, can be found in the how-to guide\n\n\n\nThis has only scratched the surface of the information available regarding working in the BCGov GitHub organization. The most useful tool you will find yourself coming back to is the policy framework cheatsheet, which details all of the above and more. This cheatsheet will help to make sure that any new repo you open is compliant with open data policies, and you can hit the ground running with your brand new version control tools!",
    "crumbs": [
      "About",
      "Course Sections",
      "4. BCGov GitHub Organization"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "About The Workshop",
    "section": "",
    "text": "This is a 1/2 day workshop introducing participants to version control using git and the popular code hosting platform, GitHub.\nThe goal of this workshop is to teach data professionals how to harness the power of version control by giving attendees a foundation in the fundamentals of version control with git.\nGitHub is a widely-used platform for hosting and sharing code repositories, facilitating seamless collaboration among developers. Git, on the other hand, is a popular version control system that enables you to track changes in your code, collaborate with team members, and maintain a history of your project’s development."
  },
  {
    "objectID": "index.html#introduction-to-version-control-with-git-and-github",
    "href": "index.html#introduction-to-version-control-with-git-and-github",
    "title": "About The Workshop",
    "section": "",
    "text": "This is a 1/2 day workshop introducing participants to version control using git and the popular code hosting platform, GitHub.\nThe goal of this workshop is to teach data professionals how to harness the power of version control by giving attendees a foundation in the fundamentals of version control with git.\nGitHub is a widely-used platform for hosting and sharing code repositories, facilitating seamless collaboration among developers. Git, on the other hand, is a popular version control system that enables you to track changes in your code, collaborate with team members, and maintain a history of your project’s development."
  },
  {
    "objectID": "index.html#learning-outcomes",
    "href": "index.html#learning-outcomes",
    "title": "About The Workshop",
    "section": "Learning Outcomes",
    "text": "Learning Outcomes\nBy the end of this course, you will have gained a fundamental understanding of version control, enabling you to:\n\nSet up a GitHub account and install the software, git (see pre-workshop assignment)\nUnderstand the value-add of using version control to manage software and code-based data science projects\nUnderstand the basics of how automated version control systems work\nUse git—popular command-line version control software—to track local file changes\nUnderstand remote hosting platforms and why we use them\nConnect to GitHub, create a remote repository and clone a local version to your PC\nBe familiar with the public BC Gov GitHub organization which has guidelines and requirements for hosting government developed open source repositories\n\nYou will also be able to follow a standard Git workflow to manage your work under existing version control using the following steps:\n\n\n\n\n\n\n\n\nOrder\nAction\nGit Command\n\n\n\n\n1\nUpdate local\ngit pull origin main\n\n\n2\nMake changes\n(Done in editor)\n\n\n3\nStage changes\ngit add numbers.txt\n\n\n4\nCommit changes\ngit commit -m \"Add 100 to numbers.txt\"\n\n\n5\nUpdate remote\ngit push origin main\n\n\n\nThe workshop content will follow best practices for version control such as writing descriptive commit messages, including a .gitignore file and tracking relevant project files."
  },
  {
    "objectID": "index.html#who-should-take-this-course",
    "href": "index.html#who-should-take-this-course",
    "title": "About The Workshop",
    "section": "Who should take this course?",
    "text": "Who should take this course?\n\nAnyone looking to solidify their understanding of version control\nAnyone keen to learn what git or GitHub is (no prior experience necessary!)\nAnyone wondering how version control can be used to manage and collaborate on software and code-based data science projects"
  },
  {
    "objectID": "index.html#workshop-schedule",
    "href": "index.html#workshop-schedule",
    "title": "About The Workshop",
    "section": "Workshop Schedule",
    "text": "Workshop Schedule\nWhen: January 29, 2025, 9:00 - 12:30\n\n\n\n\n\n\n\n\nActivity\nStart Time\nEnd Time\n\n\n\n\nSession 1. What is version control?\n9:00\n9:30\n\n\nSession 2. Working locally with git\n9:30\n10:30\n\n\nBREAK ☕\n10:30\n10:45\n\n\nSession 3. Working remotely with GitHub\n10:45\n11:45\n\n\nSession 4. The BC Gov GitHub Organization\n11:45\n12:15\n\n\nWrap Up & Questions\n12:15\n12:30"
  },
  {
    "objectID": "index.html#pre-course-work",
    "href": "index.html#pre-course-work",
    "title": "About The Workshop",
    "section": "Pre-Course Work",
    "text": "Pre-Course Work\nImportant!\nBefore the course begins, we ask that all attendees install Git and GitBash, and have a basic text editor installed, such as Wordpad, Notepad++, Visual Studio Code, or Sublime Text. Detailed installation instructions can be found at the Installation Instructions and Set-Up page. If you encounter any issues with the installation or setup, please reach out prior to the course start so we can ensure a smooth and productive workshop experience."
  },
  {
    "objectID": "CONTRIBUTING.html",
    "href": "CONTRIBUTING.html",
    "title": "Introduction to Version Control with Git & GitHub",
    "section": "",
    "text": "Government employees, public and members of the private sector are encouraged to contribute to the repository by forking and submitting a pull request.\n(If you are new to GitHub, you might start with a basic tutorial and check out a more detailed guide to pull requests.)\nPull requests will be evaluated by the repository guardians on a schedule and if deemed beneficial will be committed to the master.\nAll contributors retain the original copyright to their stuff, but by contributing to this project, you grant a world-wide, royalty-free, perpetual, irrevocable, non-exclusive, transferable license to all users under the terms of the license under which this project is distributed.\n\nThis project was created using the bcgovr package."
  },
  {
    "objectID": "CONTRIBUTING.html#how-to-contribute",
    "href": "CONTRIBUTING.html#how-to-contribute",
    "title": "Introduction to Version Control with Git & GitHub",
    "section": "",
    "text": "Government employees, public and members of the private sector are encouraged to contribute to the repository by forking and submitting a pull request.\n(If you are new to GitHub, you might start with a basic tutorial and check out a more detailed guide to pull requests.)\nPull requests will be evaluated by the repository guardians on a schedule and if deemed beneficial will be committed to the master.\nAll contributors retain the original copyright to their stuff, but by contributing to this project, you grant a world-wide, royalty-free, perpetual, irrevocable, non-exclusive, transferable license to all users under the terms of the license under which this project is distributed.\n\nThis project was created using the bcgovr package."
  }
]